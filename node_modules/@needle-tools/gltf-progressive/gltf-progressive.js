var $e = Object.defineProperty;
var Ue = (a, t, e) => t in a ? $e(a, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : a[t] = e;
var d = (a, t, e) => (Ue(a, typeof t != "symbol" ? t + "" : t, e), e), _e = (a, t, e) => {
  if (!t.has(a))
    throw TypeError("Cannot " + e);
};
var m = (a, t, e) => (_e(a, t, "read from private field"), e ? e.call(a) : t.get(a)), K = (a, t, e) => {
  if (t.has(a))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(a) : t.set(a, e);
}, U = (a, t, e, s) => (_e(a, t, "write to private field"), s ? s.call(a, e) : t.set(a, e), e);
import { BufferGeometry as ge, Mesh as H, Material as ze, Texture as se, TextureLoader as Ve, Matrix4 as Se, Clock as Ne, MeshStandardMaterial as We, Sphere as Xe, Box3 as be, Vector3 as z } from "three";
import { GLTFLoader as qe } from "three/examples/jsm/loaders/GLTFLoader.js";
import { MeshoptDecoder as Ke } from "three/examples/jsm/libs/meshopt_decoder.module.js";
import { DRACOLoader as Ye } from "three/examples/jsm/loaders/DRACOLoader.js";
import { KTX2Loader as He } from "three/examples/jsm/loaders/KTX2Loader.js";
const Ce = "";
globalThis.GLTF_PROGRESSIVE_VERSION = Ce;
console.debug(`[gltf-progressive] version ${Ce}`);
let j = "https://www.gstatic.com/draco/versioned/decoders/1.5.7/", ae = "https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/";
const Je = j, Qe = ae;
fetch(j + "draco_decoder.js", { method: "head" }).catch((a) => {
  j === Je && (j = "./include/draco/"), ae === Qe && (ae = "./include/ktx2/");
});
function gt(a) {
  j = a;
}
function pt(a) {
  ae = a;
}
let Q, he, Z;
function Be(a) {
  return Q || (Q = new Ye(), Q.setDecoderPath(j), Q.setDecoderConfig({ type: "js" })), Z || (Z = new He(), Z.setTranscoderPath(ae)), he || (he = Ke), a ? Z.detectSupport(a) : a !== null && console.warn("No renderer provided to detect ktx2 support - loading KTX2 textures might fail"), { dracoLoader: Q, ktx2Loader: Z, meshoptDecoder: he };
}
function Ie(a) {
  a.dracoLoader || a.setDRACOLoader(Q), a.ktx2Loader || a.setKTX2Loader(Z), a.meshoptDecoder || a.setMeshoptDecoder(he);
}
le("debugprogressive");
function le(a) {
  if (typeof window > "u")
    return !1;
  const e = new URL(window.location.href).searchParams.get(a);
  return e == null || e === "0" || e === "false" ? !1 : e === "" ? !0 : e;
}
function Ze(a, t) {
  if (t === void 0 || t.startsWith("./") || t.startsWith("http") || a === void 0)
    return t;
  const e = a.lastIndexOf("/");
  if (e >= 0) {
    const s = a.substring(0, e + 1);
    for (; s.endsWith("/") && t.startsWith("/"); )
      t = t.substring(1);
    return s + t;
  }
  return t;
}
let re;
function je() {
  return re !== void 0 || (re = /iPhone|iPad|iPod|Android|IEMobile/i.test(navigator.userAgent), le("debugprogressive") && console.log("[glTF Progressive]: isMobileDevice", re)), re;
}
const ve = Symbol("needle:raycast-mesh");
function me(a) {
  return (a == null ? void 0 : a[ve]) instanceof ge ? a[ve] : null;
}
function et(a, t) {
  if ((a.type === "Mesh" || a.type === "SkinnedMesh") && !me(a)) {
    const s = tt(t);
    s.userData = { isRaycastMesh: !0 }, a[ve] = s;
  }
}
function yt(a = !0) {
  if (a) {
    if (ie)
      return;
    const t = ie = H.prototype.raycast;
    H.prototype.raycast = function(e, s) {
      const n = this, r = me(n);
      let i;
      r && n.isMesh && (i = n.geometry, n.geometry = r), t.call(this, e, s), i && (n.geometry = i);
    };
  } else {
    if (!ie)
      return;
    H.prototype.raycast = ie, ie = null;
  }
}
let ie = null;
function tt(a) {
  const t = new ge();
  for (const e in a.attributes)
    t.setAttribute(e, a.getAttribute(e));
  return t.setIndex(a.getIndex()), t;
}
const Y = new Array(), V = "NEEDLE_progressive", x = le("debugprogressive"), Me = Symbol("needle-progressive-texture"), oe = /* @__PURE__ */ new Map(), Oe = /* @__PURE__ */ new Set();
if (x) {
  let a = function() {
    t += 1, console.log("Toggle LOD level", t, oe), oe.forEach((n, r) => {
      for (const i of n.keys) {
        const o = r[i];
        if (o != null) {
          if (o.isBufferGeometry === !0) {
            const l = _.getMeshLODInformation(o), u = l ? Math.min(t, l.lods.length) : 0;
            r["DEBUG:LOD"] = t, _.assignMeshLOD(r, u), l && (e = Math.max(e, l.lods.length - 1));
          } else if (r.isMaterial === !0) {
            r["DEBUG:LOD"] = t, _.assignTextureLOD(r, t);
            break;
          }
        }
      }
    }), t >= e && (t = -1);
  }, t = -1, e = 2, s = !1;
  window.addEventListener("keyup", (n) => {
    n.key === "p" && a(), n.key === "w" && (s = !s, Oe && Oe.forEach((r) => {
      r.name != "BackgroundCubeMaterial" && r.glyphMap == null && "wireframe" in r && (r.wireframe = s);
    }));
  });
}
function Te(a, t, e) {
  var n;
  if (!x)
    return;
  oe.has(a) || oe.set(a, { keys: [], sourceId: e });
  const s = oe.get(a);
  ((n = s == null ? void 0 : s.keys) == null ? void 0 : n.includes(t)) == !1 && s.keys.push(t);
}
const v = class {
  constructor(t, e) {
    d(this, "parser");
    d(this, "url");
    d(this, "_isLoadingMesh");
    d(this, "loadMesh", (t) => {
      var s, n;
      if (this._isLoadingMesh)
        return null;
      const e = (n = (s = this.parser.json.meshes[t]) == null ? void 0 : s.extensions) == null ? void 0 : n[V];
      return e ? (this._isLoadingMesh = !0, this.parser.getDependency("mesh", t).then((r) => {
        var i;
        return this._isLoadingMesh = !1, r && v.registerMesh(this.url, e.guid, r, (i = e.lods) == null ? void 0 : i.length, void 0, e), r;
      })) : null;
    });
    x && console.log("Progressive extension registered for", e), this.parser = t, this.url = e;
  }
  /** The name of the extension */
  get name() {
    return V;
  }
  static getMeshLODInformation(t) {
    const e = this.getAssignedLODInformation(t);
    return e != null && e.key ? this.lodInfos.get(e.key) : null;
  }
  static getMaterialMinMaxLODsCount(t, e) {
    const s = this, n = "LODS:minmax", r = t[n];
    if (r != null)
      return r;
    if (e || (e = {
      min_count: 1 / 0,
      max_count: 0,
      lods: []
    }), Array.isArray(t)) {
      for (const o of t)
        this.getMaterialMinMaxLODsCount(o, e);
      return t[n] = e, e;
    }
    if (x === "verbose" && console.log("getMaterialMinMaxLODsCount", t), t.type === "ShaderMaterial" || t.type === "RawShaderMaterial") {
      const o = t;
      for (const l of Object.keys(o.uniforms)) {
        const u = o.uniforms[l].value;
        (u == null ? void 0 : u.isTexture) === !0 && i(u, e);
      }
    } else if (t.isMaterial)
      for (const o of Object.keys(t)) {
        const l = t[o];
        (l == null ? void 0 : l.isTexture) === !0 && i(l, e);
      }
    return t[n] = e, e;
    function i(o, l) {
      const u = s.getAssignedLODInformation(o);
      if (u) {
        const c = s.lodInfos.get(u.key);
        if (c && c.lods) {
          l.min_count = Math.min(l.min_count, c.lods.length), l.max_count = Math.max(l.max_count, c.lods.length);
          for (let g = 0; g < c.lods.length; g++) {
            const p = c.lods[g];
            p.width && (l.lods[g] = l.lods[g] || { min_height: 1 / 0, max_height: 0 }, l.lods[g].min_height = Math.min(l.lods[g].min_height, p.height), l.lods[g].max_height = Math.max(l.lods[g].max_height, p.height));
          }
        }
      }
    }
  }
  /** Check if a LOD level is available for a mesh or a texture
   * @param obj the mesh or texture to check
   * @param level the level of detail to check for (0 is the highest resolution). If undefined, the function checks if any LOD level is available
   * @returns true if the LOD level is available (or if any LOD level is available if level is undefined)
   */
  static hasLODLevelAvailable(t, e) {
    var r;
    if (Array.isArray(t)) {
      for (const i of t)
        if (this.hasLODLevelAvailable(i, e))
          return !0;
      return !1;
    }
    if (t.isMaterial === !0) {
      for (const i of Object.keys(t)) {
        const o = t[i];
        if (o && o.isTexture && this.hasLODLevelAvailable(o, e))
          return !0;
      }
      return !1;
    } else if (t.isGroup === !0) {
      for (const i of t.children)
        if (i.isMesh === !0 && this.hasLODLevelAvailable(i, e))
          return !0;
    }
    let s, n;
    if (t.isMesh ? s = t.geometry : (t.isBufferGeometry || t.isTexture) && (s = t), s && (r = s == null ? void 0 : s.userData) != null && r.LODS) {
      const i = s.userData.LODS;
      if (n = this.lodInfos.get(i.key), e === void 0)
        return n != null;
      if (n)
        return Array.isArray(n.lods) ? e < n.lods.length : e === 0;
    }
    return !1;
  }
  /** Load a different resolution of a mesh (if available)
   * @param context the context
   * @param source the sourceid of the file from which the mesh is loaded (this is usually the component's sourceId)
   * @param mesh the mesh to load the LOD for
   * @param level the level of detail to load (0 is the highest resolution)
   * @returns a promise that resolves to the mesh with the requested LOD level
   * @example
   * ```javascript
   * const mesh = this.gameObject as Mesh;
   * NEEDLE_progressive.assignMeshLOD(context, sourceId, mesh, 1).then(mesh => {
   *    console.log("Mesh with LOD level 1 loaded", mesh);
   * });
   * ```
   */
  static assignMeshLOD(t, e) {
    var s;
    if (!t)
      return Promise.resolve(null);
    if (t instanceof H || t.isMesh === !0) {
      const n = t.geometry, r = this.getAssignedLODInformation(n);
      if (!r)
        return Promise.resolve(null);
      for (const i of Y)
        (s = i.onBeforeGetLODMesh) == null || s.call(i, t, e);
      return t["LOD:requested level"] = e, v.getOrLoadLOD(n, e).then((i) => {
        if (t["LOD:requested level"] === e) {
          if (delete t["LOD:requested level"], Array.isArray(i)) {
            const o = r.index || 0;
            i = i[o];
          }
          i && n != i && ((i == null ? void 0 : i.isBufferGeometry) ? (t.geometry = i, x && Te(t, "geometry", r.url)) : x && console.error("Invalid LOD geometry", i));
        }
        return i;
      }).catch((i) => (console.error("Error loading mesh LOD", t, i), null));
    } else
      x && console.error("Invalid call to assignMeshLOD: Request mesh LOD but the object is not a mesh", t);
    return Promise.resolve(null);
  }
  static assignTextureLOD(t, e = 0) {
    if (!t)
      return Promise.resolve(null);
    if (t.isMesh === !0) {
      const s = t;
      if (Array.isArray(s.material)) {
        const n = new Array();
        for (const r of s.material) {
          const i = this.assignTextureLOD(r, e);
          n.push(i);
        }
        return Promise.all(n).then((r) => {
          const i = new Array();
          for (const o of r)
            Array.isArray(o) && i.push(...o);
          return i;
        });
      } else
        return this.assignTextureLOD(s.material, e);
    }
    if (t instanceof ze || t.isMaterial === !0) {
      const s = t, n = [], r = new Array();
      if (x && Oe.add(s), s.uniforms && (s.isRawShaderMaterial || s.isShaderMaterial === !0)) {
        const i = s;
        for (const o of Object.keys(i.uniforms)) {
          const l = i.uniforms[o].value;
          if ((l == null ? void 0 : l.isTexture) === !0) {
            const u = this.assignTextureLODForSlot(l, e, s, o).then((c) => (c && i.uniforms[o].value != c && (i.uniforms[o].value = c, i.uniformsNeedUpdate = !0), c));
            n.push(u), r.push(o);
          }
        }
      } else
        for (const i of Object.keys(s)) {
          const o = s[i];
          if ((o == null ? void 0 : o.isTexture) === !0) {
            const l = this.assignTextureLODForSlot(o, e, s, i);
            n.push(l), r.push(i);
          }
        }
      return Promise.all(n).then((i) => {
        const o = new Array();
        for (let l = 0; l < i.length; l++) {
          const u = i[l], c = r[l];
          u && u.isTexture === !0 ? o.push({ material: s, slot: c, texture: u, level: e }) : o.push({ material: s, slot: c, texture: null, level: e });
        }
        return o;
      });
    }
    if (t instanceof se || t.isTexture === !0) {
      const s = t;
      return this.assignTextureLODForSlot(s, e, null, null);
    }
    return Promise.resolve(null);
  }
  static assignTextureLODForSlot(t, e, s, n) {
    return (t == null ? void 0 : t.isTexture) !== !0 ? Promise.resolve(null) : n === "glyphMap" ? Promise.resolve(t) : v.getOrLoadLOD(t, e).then((r) => {
      if (Array.isArray(r))
        return null;
      if ((r == null ? void 0 : r.isTexture) === !0) {
        if (r != t) {
          if (s && n) {
            const i = s[n];
            if (i) {
              const o = this.getAssignedLODInformation(i);
              if (o && (o == null ? void 0 : o.level) < e)
                return x === "verbose" && console.warn("Assigned texture level is already higher: ", o.level, e, s, i, r), null;
            }
            s[n] = r;
          }
          if (x && n && s) {
            const i = this.getAssignedLODInformation(t);
            i && Te(s, n, i.url);
          }
        }
        return r;
      } else
        x == "verbose" && console.warn("No LOD found for", t, e);
      return null;
    }).catch((r) => (console.error("Error loading LOD", t, r), null));
  }
  afterRoot(t) {
    var e, s;
    return x && console.log("AFTER", this.url, t), (e = this.parser.json.textures) == null || e.forEach((n, r) => {
      var i;
      if (n != null && n.extensions) {
        const o = n == null ? void 0 : n.extensions[V];
        if (o) {
          if (!o.lods) {
            x && console.warn("Texture has no LODs", o);
            return;
          }
          let l = !1;
          for (const u of this.parser.associations.keys())
            if (u.isTexture === !0) {
              const c = this.parser.associations.get(u);
              (c == null ? void 0 : c.textures) === r && (l = !0, v.registerTexture(this.url, u, (i = o.lods) == null ? void 0 : i.length, r, o));
            }
          l || this.parser.getDependency("texture", r).then((u) => {
            var c;
            u && v.registerTexture(this.url, u, (c = o.lods) == null ? void 0 : c.length, r, o);
          });
        }
      }
    }), (s = this.parser.json.meshes) == null || s.forEach((n, r) => {
      if (n != null && n.extensions) {
        const i = n == null ? void 0 : n.extensions[V];
        if (i && i.lods) {
          for (const o of this.parser.associations.keys())
            if (o.isMesh) {
              const l = this.parser.associations.get(o);
              (l == null ? void 0 : l.meshes) === r && v.registerMesh(this.url, i.guid, o, i.lods.length, l.primitives, i);
            }
        }
      }
    }), null;
  }
  static async getOrLoadLOD(t, e) {
    var o, l, u, c;
    const s = x == "verbose", n = t.userData.LODS;
    if (!n)
      return null;
    const r = n == null ? void 0 : n.key;
    let i;
    if (t.isTexture === !0) {
      const g = t;
      g.source && g.source[Me] && (i = g.source[Me]);
    }
    if (i || (i = v.lodInfos.get(r)), i) {
      if (e > 0) {
        let M = !1;
        const w = Array.isArray(i.lods);
        if (w && e >= i.lods.length ? M = !0 : w || (M = !0), M)
          return this.lowresCache.get(r);
      }
      const g = Array.isArray(i.lods) ? (o = i.lods[e]) == null ? void 0 : o.path : i.lods;
      if (!g)
        return x && !i["missing:uri"] && (i["missing:uri"] = !0, console.warn("Missing uri for progressive asset for LOD " + e, i)), null;
      const p = Ze(n.url, g);
      if (p.endsWith(".glb") || p.endsWith(".gltf")) {
        if (!i.guid)
          return console.warn("missing pointer for glb/gltf texture", i), null;
        const M = p + "_" + i.guid, w = this.previouslyLoaded.get(M);
        if (w !== void 0) {
          s && console.log(`LOD ${e} was already loading/loaded: ${M}`);
          let h = await w.catch(($) => (console.error(`Error loading LOD ${e} from ${p}
`, $), null)), B = !1;
          if (h == null || (h instanceof se && t instanceof se ? (l = h.image) != null && l.data || (u = h.source) != null && u.data ? h = this.copySettings(t, h) : (B = !0, this.previouslyLoaded.delete(M)) : h instanceof ge && t instanceof ge && ((c = h.attributes.position) != null && c.array || (B = !0, this.previouslyLoaded.delete(M)))), !B)
            return h;
        }
        const L = i, F = new Promise(async (h, B) => {
          const $ = new qe();
          Ie($), x && (await new Promise((A) => setTimeout(A, 1e3)), s && console.warn("Start loading (delayed) " + p, L.guid));
          let I = p;
          if (L && Array.isArray(L.lods)) {
            const A = L.lods[e];
            A.hash && (I += "?v=" + A.hash);
          }
          const S = await $.loadAsync(I).catch((A) => (console.error(`Error loading LOD ${e} from ${p}
`, A), null));
          if (!S)
            return null;
          const X = S.parser;
          s && console.log("Loading finished " + p, L.guid);
          let T = 0;
          if (S.parser.json.textures) {
            let A = !1;
            for (const f of S.parser.json.textures) {
              if (f != null && f.extensions) {
                const y = f == null ? void 0 : f.extensions[V];
                if (y != null && y.guid && y.guid === L.guid) {
                  A = !0;
                  break;
                }
              }
              T++;
            }
            if (A) {
              let f = await X.getDependency("texture", T);
              return f && v.assignLODInformation(n.url, f, r, e, void 0, void 0), s && console.log('change "' + t.name + '" → "' + f.name + '"', p, T, f, M), t instanceof se && (f = this.copySettings(t, f)), f && (f.guid = L.guid), h(f);
            } else
              x && console.warn("Could not find texture with guid", L.guid, S.parser.json);
          }
          if (T = 0, S.parser.json.meshes) {
            let A = !1;
            for (const f of S.parser.json.meshes) {
              if (f != null && f.extensions) {
                const y = f == null ? void 0 : f.extensions[V];
                if (y != null && y.guid && y.guid === L.guid) {
                  A = !0;
                  break;
                }
              }
              T++;
            }
            if (A) {
              const f = await X.getDependency("mesh", T), y = L;
              if (s && console.log(`Loaded Mesh "${f.name}"`, p, T, f, M), f.isMesh === !0) {
                const O = f.geometry;
                return v.assignLODInformation(n.url, O, r, e, void 0, y.density), h(O);
              } else {
                const O = new Array();
                for (let b = 0; b < f.children.length; b++) {
                  const E = f.children[b];
                  if (E.isMesh === !0) {
                    const q = E.geometry;
                    v.assignLODInformation(n.url, q, r, e, b, y.density), O.push(q);
                  }
                }
                return h(O);
              }
            } else
              x && console.warn("Could not find mesh with guid", L.guid, S.parser.json);
          }
          return h(null);
        });
        return this.previouslyLoaded.set(M, F), await F;
      } else if (t instanceof se) {
        s && console.log("Load texture from uri: " + p);
        const w = await new Ve().loadAsync(p);
        return w ? (w.guid = i.guid, w.flipY = !1, w.needsUpdate = !0, w.colorSpace = t.colorSpace, s && console.log(i, w)) : x && console.warn("failed loading", p), w;
      }
    } else
      x && console.warn(`Can not load LOD ${e}: no LOD info found for "${r}" ${t.name}`, t.type);
    return null;
  }
  static assignLODInformation(t, e, s, n, r, i) {
    if (!e)
      return;
    e.userData || (e.userData = {});
    const o = new st(t, s, n, r, i);
    e.userData.LODS = o;
  }
  static getAssignedLODInformation(t) {
    var e;
    return ((e = t == null ? void 0 : t.userData) == null ? void 0 : e.LODS) || null;
  }
  // private static readonly _copiedTextures: WeakMap<Texture, Texture> = new Map();
  static copySettings(t, e) {
    return e = e.clone(), x && console.warn(`Copying texture settings
`, t.uuid, `
`, e.uuid), e.offset = t.offset, e.repeat = t.repeat, e.colorSpace = t.colorSpace, e.magFilter = t.magFilter, e.minFilter = t.minFilter, e.wrapS = t.wrapS, e.wrapT = t.wrapT, e.flipY = t.flipY, e.anisotropy = t.anisotropy, e.mipmaps || (e.generateMipmaps = t.generateMipmaps), e;
  }
};
let _ = v;
/**
 * Register a texture with LOD information
 */
d(_, "registerTexture", (t, e, s, n, r) => {
  if (x && console.log("> Progressive: register texture", n, e.name, e.uuid, e, r), !e) {
    x && console.error("gltf-progressive: Register texture without texture");
    return;
  }
  e.source && (e.source[Me] = r);
  const i = r.guid;
  v.assignLODInformation(t, e, i, s, n, void 0), v.lodInfos.set(i, r), v.lowresCache.set(i, e);
}), /**
 * Register a mesh with LOD information
 */
d(_, "registerMesh", (t, e, s, n, r, i) => {
  var u;
  x && console.log("> Progressive: register mesh", r, s.name, i, s.uuid, s);
  const o = s.geometry;
  if (!o) {
    x && console.warn("gltf-progressive: Register mesh without geometry");
    return;
  }
  o.userData || (o.userData = {}), v.assignLODInformation(t, o, e, n, r, i.density), v.lodInfos.set(e, i);
  let l = v.lowresCache.get(e);
  l ? l.push(s.geometry) : l = [s.geometry], v.lowresCache.set(e, l), n > 0 && !me(s) && et(s, o);
  for (const c of Y)
    (u = c.onRegisteredNewMesh) == null || u.call(c, s, i);
}), /** A map of key = asset uuid and value = LOD information */
d(_, "lodInfos", /* @__PURE__ */ new Map()), /** cache of already loaded mesh lods */
d(_, "previouslyLoaded", /* @__PURE__ */ new Map()), /** this contains the geometry/textures that were originally loaded */
d(_, "lowresCache", /* @__PURE__ */ new Map());
class st {
  constructor(t, e, s, n, r) {
    d(this, "url");
    /** the key to lookup the LOD information */
    d(this, "key");
    d(this, "level");
    /** For multi objects (e.g. a group of meshes) this is the index of the object */
    d(this, "index");
    /** the mesh density */
    d(this, "density");
    this.url = t, this.key = e, this.level = s, n != null && (this.index = n), r != null && (this.density = r);
  }
}
const k = le("debugprogressive"), rt = le("noprogressive"), De = Symbol("Needle:LODSManager"), we = Symbol("Needle:LODState"), J = Symbol("Needle:CurrentLOD"), R = { mesh_lod: -1, texture_lod: -1 };
var C, N, pe, ee, te, ye, W;
const P = class {
  // readonly plugins: NEEDLE_progressive_plugin[] = [];
  constructor(t, e) {
    d(this, "context");
    d(this, "renderer");
    d(this, "projectionScreenMatrix", new Se());
    /**
     * The target triangle density is the desired max amount of triangles on screen when the mesh is filling the screen.  
     * @default 200_000
     */
    d(this, "targetTriangleDensity", 2e5);
    /**
     * The update interval in frames. If set to 0, the LODs will be updated every frame. If set to 2, the LODs will be updated every second frame, etc.
     * @default "auto"
     */
    d(this, "updateInterval", "auto");
    K(this, C, 1);
    /**
     * If set to true, the LODsManager will not update the LODs.
     * @default false
     */
    d(this, "pause", !1);
    /**
     * When set to true the LODsManager will not update the LODs. This can be used to manually update the LODs using the `update` method.  
     * Otherwise the LODs will be updated automatically when the renderer renders the scene.
     * @default false
     */
    d(this, "manual", !1);
    d(this, "_lodchangedlisteners", []);
    K(this, N, void 0);
    K(this, pe, new Ne());
    K(this, ee, 0);
    K(this, te, 0);
    K(this, ye, 0);
    K(this, W, 0);
    d(this, "_fpsBuffer", [60, 60, 60, 60, 60]);
    // private testIfLODLevelsAreAvailable() {
    d(this, "_sphere", new Xe());
    d(this, "_tempBox", new be());
    d(this, "_tempBox2", new be());
    d(this, "tempMatrix", new Se());
    d(this, "_tempWorldPosition", new z());
    d(this, "_tempBoxSize", new z());
    d(this, "_tempBox2Size", new z());
    this.renderer = t, this.context = { ...e };
  }
  /** @internal */
  static getObjectLODState(t) {
    return t[we];
  }
  static addPlugin(t) {
    Y.push(t);
  }
  static removePlugin(t) {
    const e = Y.indexOf(t);
    e >= 0 && Y.splice(e, 1);
  }
  /**
   * Gets the LODsManager for the given renderer. If the LODsManager does not exist yet, it will be created.  
   * @param renderer The renderer to get the LODsManager for.
   * @returns The LODsManager instance.
   */
  static get(t, e) {
    if (t[De])
      return console.debug("[gltf-progressive] LODsManager already exists for this renderer"), t[De];
    const s = new P(t, {
      engine: "unknown",
      ...e
    });
    return t[De] = s, s;
  }
  /** @deprecated use static `LODsManager.addPlugin()` method. This getter will be removed in later versions */
  get plugins() {
    return Y;
  }
  addEventListener(t, e) {
    t === "changed" && this._lodchangedlisteners.push(e);
  }
  removeEventListener(t, e) {
    if (t === "changed") {
      const s = this._lodchangedlisteners.indexOf(e);
      s >= 0 && this._lodchangedlisteners.splice(s, 1);
    }
  }
  /**
   * Enable the LODsManager. This will replace the render method of the renderer with a method that updates the LODs.
   */
  enable() {
    if (m(this, N))
      return;
    console.debug("[gltf-progressive] Enabling LODsManager for renderer");
    let t = 0;
    U(this, N, this.renderer.render);
    const e = this;
    Be(this.renderer), this.renderer.render = function(s, n) {
      const r = e.renderer.getRenderTarget();
      (r == null || "isXRRenderTarget" in r && r.isXRRenderTarget) && (t = 0, U(e, ee, m(e, ee) + 1), U(e, te, m(e, pe).getDelta()), U(e, ye, m(e, ye) + m(e, te)), e._fpsBuffer.shift(), e._fpsBuffer.push(1 / m(e, te)), U(e, W, e._fpsBuffer.reduce((o, l) => o + l) / e._fpsBuffer.length), k && m(e, ee) % 200 === 0 && console.log("FPS", Math.round(m(e, W)), "Interval:", m(e, C)));
      const i = t++;
      m(e, N).call(this, s, n), e.onAfterRender(s, n, i);
    };
  }
  disable() {
    m(this, N) && (this.renderer.render = m(this, N), U(this, N, void 0));
  }
  update(t, e) {
    this.internalUpdate(t, e);
  }
  onAfterRender(t, e, s) {
    if (this.pause)
      return;
    const r = this.renderer.renderLists.get(t, 0).opaque;
    let i = !0;
    if (r.length === 1) {
      const o = r[0].material;
      (o.name === "EffectMaterial" || o.name === "CopyShader") && (i = !1);
    }
    if ((e.parent && e.parent.type === "CubeCamera" || s >= 1 && e.type === "OrthographicCamera") && (i = !1), i) {
      if (rt || (this.updateInterval === "auto" ? m(this, W) < 40 && m(this, C) < 10 ? (U(this, C, m(this, C) + 1), k && console.warn("↓ Reducing LOD updates", m(this, C), m(this, W).toFixed(0))) : m(this, W) >= 60 && m(this, C) > 1 && (U(this, C, m(this, C) - 1), k && console.warn("↑ Increasing LOD updates", m(this, C), m(this, W).toFixed(0))) : U(this, C, this.updateInterval), m(this, C) > 0 && m(this, ee) % m(this, C) != 0))
        return;
      this.internalUpdate(t, e);
    }
  }
  /**
   * Update LODs in a scene
   */
  internalUpdate(t, e) {
    var l, u;
    const s = this.renderer.renderLists.get(t, 0), n = s.opaque;
    this.projectionScreenMatrix.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse);
    const r = this.targetTriangleDensity;
    for (const c of n) {
      if (c.material && (((l = c.geometry) == null ? void 0 : l.type) === "BoxGeometry" || ((u = c.geometry) == null ? void 0 : u.type) === "BufferGeometry") && (c.material.name === "SphericalGaussianBlur" || c.material.name == "BackgroundCubeMaterial" || c.material.name === "CubemapFromEquirect" || c.material.name === "EquirectangularToCubeUV")) {
        k && (c.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"] || (c.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"] = !0, console.warn("Ignoring skybox or BLIT object", c, c.material.name, c.material.type)));
        continue;
      }
      switch (c.material.type) {
        case "LineBasicMaterial":
        case "LineDashedMaterial":
        case "PointsMaterial":
        case "ShadowMaterial":
        case "MeshDistanceMaterial":
        case "MeshDepthMaterial":
          continue;
      }
      if (k === "color" && c.material && !c.object.progressive_debug_color) {
        c.object.progressive_debug_color = !0;
        const p = Math.random() * 16777215, M = new We({ color: p });
        c.object.material = M;
      }
      const g = c.object;
      (g instanceof H || g.isMesh) && this.updateLODs(t, e, g, r);
    }
    const i = s.transparent;
    for (const c of i) {
      const g = c.object;
      (g instanceof H || g.isMesh) && this.updateLODs(t, e, g, r);
    }
    const o = s.transmissive;
    for (const c of o) {
      const g = c.object;
      (g instanceof H || g.isMesh) && this.updateLODs(t, e, g, r);
    }
  }
  /** Update the LOD levels for the renderer. */
  updateLODs(t, e, s, n) {
    var o, l;
    s.userData || (s.userData = {});
    let r = s[we];
    if (r || (r = new it(), s[we] = r), r.frames++ < 2)
      return;
    for (const u of Y)
      (o = u.onBeforeUpdateLOD) == null || o.call(u, this.renderer, t, e, s);
    this.calculateLodLevel(e, s, r, n, R), R.mesh_lod = Math.round(R.mesh_lod), R.texture_lod = Math.round(R.texture_lod), R.mesh_lod >= 0 && this.loadProgressiveMeshes(s, R.mesh_lod);
    let i = R.texture_lod;
    if (s.material && i >= 0) {
      const u = s["DEBUG:LOD"];
      u != null && (i = u), this.loadProgressiveTextures(s.material, i);
    }
    for (const u of Y)
      (l = u.onAfterUpdatedLOD) == null || l.call(u, this.renderer, t, e, s, R);
    r.lastLodLevel_Mesh = R.mesh_lod, r.lastLodLevel_Texture = R.texture_lod;
  }
  /** Load progressive textures for the given material
   * @param material the material to load the textures for
   * @param level the LOD level to load. Level 0 is the best quality, higher levels are lower quality
   * @returns Promise with true if the LOD was loaded, false if not
   */
  loadProgressiveTextures(t, e) {
    if (!t)
      return;
    if (Array.isArray(t)) {
      for (const n of t)
        this.loadProgressiveTextures(n, e);
      return;
    }
    let s = !1;
    (t[J] === void 0 || e < t[J]) && (s = !0), s && (t[J] = e, _.assignTextureLOD(t, e).then((n) => {
      this._lodchangedlisteners.forEach((r) => r({ type: "texture", level: e, object: t }));
    }));
  }
  /** Load progressive meshes for the given mesh
   * @param mesh the mesh to load the LOD for
   * @param index the index of the mesh if it's part of a group
   * @param level the LOD level to load. Level 0 is the best quality, higher levels are lower quality
   * @returns Promise with true if the LOD was loaded, false if not
   */
  loadProgressiveMeshes(t, e) {
    if (!t)
      return Promise.resolve(null);
    if (t[J] !== e) {
      t[J] = e;
      const s = t.geometry;
      return _.assignMeshLOD(t, e).then((n) => (n && t[J] == e && s != t.geometry && this._lodchangedlisteners.forEach((r) => r({ type: "mesh", level: e, object: t })), n));
    }
    return Promise.resolve(null);
  }
  static isInside(t, e) {
    const s = t.min, n = t.max, r = (s.x + n.x) * 0.5, i = (s.y + n.y) * 0.5;
    return this._tempPtInside.set(r, i, s.z).applyMatrix4(e).z < 0;
  }
  calculateLodLevel(t, e, s, n, r) {
    var F;
    if (!e) {
      r.mesh_lod = -1, r.texture_lod = -1;
      return;
    }
    if (!t) {
      r.mesh_lod = -1, r.texture_lod = -1;
      return;
    }
    let o = 10 + 1, l = !1;
    if (k && e["DEBUG:LOD"] != null)
      return e["DEBUG:LOD"];
    const u = _.getMeshLODInformation(e.geometry), c = u == null ? void 0 : u.lods, g = c && c.length > 0, p = _.getMaterialMinMaxLODsCount(e.material), M = (p == null ? void 0 : p.min_count) != 1 / 0 && p.min_count > 0 && p.max_count > 0;
    if (!g && !M) {
      r.mesh_lod = 0, r.texture_lod = 0;
      return;
    }
    g || (l = !0, o = 0);
    const w = this.renderer.domElement.clientHeight || this.renderer.domElement.height;
    let L = e.geometry.boundingBox;
    if (e.type === "SkinnedMesh") {
      const D = e;
      if (!D.boundingBox)
        D.computeBoundingBox();
      else if (s.frames % 30 === 0) {
        const h = me(D), B = D.geometry;
        h && (D.geometry = h), D.computeBoundingBox(), D.geometry = B;
      }
      L = D.boundingBox;
    }
    if (L && t.isPerspectiveCamera) {
      const D = t;
      if (e.geometry.attributes.color && e.geometry.attributes.color.count < 100 && e.geometry.boundingSphere) {
        this._sphere.copy(e.geometry.boundingSphere), this._sphere.applyMatrix4(e.matrixWorld);
        const f = t.getWorldPosition(this._tempWorldPosition);
        if (this._sphere.containsPoint(f)) {
          r.mesh_lod = 0, r.texture_lod = 0;
          return;
        }
      }
      if (this._tempBox.copy(L), this._tempBox.applyMatrix4(e.matrixWorld), P.isInside(this._tempBox, this.projectionScreenMatrix)) {
        r.mesh_lod = 0, r.texture_lod = 0;
        return;
      }
      if (this._tempBox.applyMatrix4(this.projectionScreenMatrix), this.renderer.xr.enabled && D.fov > 70) {
        const f = this._tempBox.min, y = this._tempBox.max;
        let O = f.x, b = f.y, E = y.x, q = y.y;
        const ce = 2, xe = 1.5, ue = (f.x + y.x) * 0.5, fe = (f.y + y.y) * 0.5;
        O = (O - ue) * ce + ue, b = (b - fe) * ce + fe, E = (E - ue) * ce + ue, q = (q - fe) * ce + fe;
        const Ge = O < 0 && E > 0 ? 0 : Math.min(Math.abs(f.x), Math.abs(y.x)), Fe = b < 0 && q > 0 ? 0 : Math.min(Math.abs(f.y), Math.abs(y.y)), Le = Math.max(Ge, Fe);
        s.lastCentrality = (xe - Le) * (xe - Le) * (xe - Le);
      } else
        s.lastCentrality = 1;
      const h = this._tempBox.getSize(this._tempBoxSize);
      h.multiplyScalar(0.5), screen.availHeight > 0 && w > 0 && h.multiplyScalar(w / screen.availHeight), h.x *= D.aspect;
      const B = t.matrixWorldInverse, $ = this._tempBox2;
      $.copy(L), $.applyMatrix4(e.matrixWorld), $.applyMatrix4(B);
      const I = $.getSize(this._tempBox2Size), S = Math.max(I.x, I.y);
      if (Math.max(h.x, h.y) != 0 && S != 0 && (h.z = I.z / Math.max(I.x, I.y) * Math.max(h.x, h.y)), s.lastScreenCoverage = Math.max(h.x, h.y, h.z), s.lastScreenspaceVolume.copy(h), s.lastScreenCoverage *= s.lastCentrality, k && P.debugDrawLine) {
        const f = this.tempMatrix.copy(this.projectionScreenMatrix);
        f.invert();
        const y = P.corner0, O = P.corner1, b = P.corner2, E = P.corner3;
        y.copy(this._tempBox.min), O.copy(this._tempBox.max), O.x = y.x, b.copy(this._tempBox.max), b.y = y.y, E.copy(this._tempBox.max);
        const q = (y.z + E.z) * 0.5;
        y.z = O.z = b.z = E.z = q, y.applyMatrix4(f), O.applyMatrix4(f), b.applyMatrix4(f), E.applyMatrix4(f), P.debugDrawLine(y, O, 255), P.debugDrawLine(y, b, 255), P.debugDrawLine(O, E, 255), P.debugDrawLine(b, E, 255);
      }
      let T = 999;
      if (c && s.lastScreenCoverage > 0) {
        for (let f = 0; f < c.length; f++)
          if (c[f].density / s.lastScreenCoverage < n) {
            T = f;
            break;
          }
      }
      T < o && (o = T, l = !0);
    }
    if (l ? r.mesh_lod = o : r.mesh_lod = s.lastLodLevel_Mesh, k && r.mesh_lod != s.lastLodLevel_Mesh) {
      const h = c == null ? void 0 : c[r.mesh_lod];
      h && console.log(`Mesh LOD changed: ${s.lastLodLevel_Mesh} → ${r.mesh_lod} (${h.density.toFixed(0)}) - ${e.name}`);
    }
    if (M) {
      const D = "saveData" in globalThis.navigator && globalThis.navigator.saveData === !0;
      if (s.lastLodLevel_Texture < 0) {
        if (r.texture_lod = p.max_count - 1, k) {
          const h = p.lods[p.max_count - 1];
          k && console.log(`First Texture LOD ${r.texture_lod} (${h.max_height}px) - ${e.name}`);
        }
      } else {
        const h = s.lastScreenspaceVolume.x + s.lastScreenspaceVolume.y + s.lastScreenspaceVolume.z;
        let B = s.lastScreenCoverage * 2;
        ((F = this.context) == null ? void 0 : F.engine) === "model-viewer" && (B *= 2);
        const I = w / window.devicePixelRatio * B;
        for (let S = p.lods.length - 1; S >= 0; S--) {
          let X = p.lods[S];
          if (!(D && X.max_height >= 2048) && !(je() && X.max_height > 4096) && X.max_height > I) {
            if (r.texture_lod = S, r.texture_lod < s.lastLodLevel_Texture) {
              const T = X.max_height;
              k && console.log(`Texture LOD changed: ${s.lastLodLevel_Texture} → ${r.texture_lod} = ${T}px 
Screensize: ${I.toFixed(0)}px, Coverage: ${(100 * s.lastScreenCoverage).toFixed(2)}%, Volume ${h.toFixed(1)} 
${e.name}`);
            }
            break;
          }
        }
      }
    } else
      r.texture_lod = 0;
  }
};
let G = P;
C = new WeakMap(), N = new WeakMap(), pe = new WeakMap(), ee = new WeakMap(), te = new WeakMap(), ye = new WeakMap(), W = new WeakMap(), /** Assign a function to draw debug lines for the LODs. This function will be called with the start and end position of the line and the color of the line when the `debugprogressive` query parameter is set.
 */
d(G, "debugDrawLine"), d(G, "corner0", new z()), d(G, "corner1", new z()), d(G, "corner2", new z()), d(G, "corner3", new z()), d(G, "_tempPtInside", new z());
class it {
  constructor() {
    d(this, "frames", 0);
    d(this, "lastLodLevel_Mesh", -1);
    d(this, "lastLodLevel_Texture", -1);
    d(this, "lastScreenCoverage", 0);
    d(this, "lastScreenspaceVolume", new z());
    d(this, "lastCentrality", 0);
  }
}
const Ae = Symbol("NEEDLE_mesh_lod"), de = Symbol("NEEDLE_texture_lod");
let ne = null;
function ke() {
  const a = nt();
  a && (a.mapURLs(function(t) {
    return Ee(), t;
  }), Ee(), ne == null || ne.disconnect(), ne = new MutationObserver((t) => {
    t.forEach((e) => {
      e.addedNodes.forEach((s) => {
        s instanceof HTMLElement && s.tagName.toLowerCase() === "model-viewer" && Re(s);
      });
    });
  }), ne.observe(document, { childList: !0, subtree: !0 }));
}
function nt() {
  if (typeof customElements > "u")
    return null;
  const a = customElements.get("model-viewer");
  return a || (customElements.whenDefined("model-viewer").then(() => {
    console.debug("[gltf-progressive] model-viewer defined"), ke();
  }), null);
}
function Ee() {
  if (typeof document > "u")
    return;
  document.querySelectorAll("model-viewer").forEach((t) => {
    Re(t);
  });
}
const Pe = /* @__PURE__ */ new WeakSet();
let ot = 0;
function Re(a) {
  if (!a || Pe.has(a))
    return null;
  Pe.add(a), console.debug("[gltf-progressive] found new model-viewer..." + ++ot + `
`, a.getAttribute("src"));
  let t = null, e = null, s = null;
  for (let n = a; n != null; n = Object.getPrototypeOf(n)) {
    const r = Object.getOwnPropertySymbols(n), i = r.find((u) => u.toString() == "Symbol(renderer)"), o = r.find((u) => u.toString() == "Symbol(scene)"), l = r.find((u) => u.toString() == "Symbol(needsRender)");
    !t && i != null && (t = a[i].threeRenderer), !e && o != null && (e = a[o]), !s && l != null && (s = a[l]);
  }
  if (t && e) {
    let n = function() {
      if (s) {
        let i = 0, o = setInterval(() => {
          if (i++ > 5) {
            clearInterval(o);
            return;
          }
          s == null || s.call(a);
        }, 300);
      }
    };
    console.debug("[gltf-progressive] setup model-viewer");
    const r = G.get(t, { engine: "model-viewer" });
    return G.addPlugin(new at()), r.enable(), r.addEventListener("changed", () => {
      s == null || s.call(a);
    }), a.addEventListener("model-visibility", (i) => {
      i.detail.visible && (s == null || s.call(a));
    }), a.addEventListener("load", () => {
      n();
    }), () => {
      r.disable();
    };
  }
  return null;
}
class at {
  constructor() {
    d(this, "_didWarnAboutMissingUrl", !1);
  }
  onBeforeUpdateLOD(t, e, s, n) {
    this.tryParseMeshLOD(e, n), this.tryParseTextureLOD(e, n);
  }
  getUrl(t) {
    if (!t)
      return null;
    let e = t.getAttribute("src");
    return e || (e = t.src), e || (this._didWarnAboutMissingUrl || console.warn("No url found in modelviewer", t), this._didWarnAboutMissingUrl = !0), e;
  }
  tryGetCurrentGLTF(t) {
    return t._currentGLTF;
  }
  tryGetCurrentModelViewer(t) {
    return t.element;
  }
  tryParseTextureLOD(t, e) {
    if (e[de] == !0)
      return;
    e[de] = !0;
    const s = this.tryGetCurrentGLTF(t), n = this.tryGetCurrentModelViewer(t), r = this.getUrl(n);
    if (r && s && e.material) {
      let i = function(l) {
        var c, g, p;
        if (l[de] == !0)
          return;
        l[de] = !0, l.userData && (l.userData.LOD = -1);
        const u = Object.keys(l);
        for (let M = 0; M < u.length; M++) {
          const w = u[M], L = l[w];
          if ((L == null ? void 0 : L.isTexture) === !0) {
            const F = (g = (c = L.userData) == null ? void 0 : c.associations) == null ? void 0 : g.textures;
            if (F == null)
              continue;
            const D = s.parser.json.textures[F];
            if (!D) {
              console.warn("Texture data not found for texture index " + F);
              continue;
            }
            if ((p = D == null ? void 0 : D.extensions) != null && p[V]) {
              const h = D.extensions[V];
              h && r && _.registerTexture(r, L, h.lods.length, F, h);
            }
          }
        }
      };
      const o = e.material;
      if (Array.isArray(o))
        for (const l of o)
          i(l);
      else
        i(o);
    }
  }
  tryParseMeshLOD(t, e) {
    var i, o;
    if (e[Ae] == !0)
      return;
    e[Ae] = !0;
    const s = this.tryGetCurrentModelViewer(t), n = this.getUrl(s);
    if (!n)
      return;
    const r = (o = (i = e.userData) == null ? void 0 : i.gltfExtensions) == null ? void 0 : o[V];
    if (r && n) {
      const l = e.uuid;
      _.registerMesh(n, l, e, 0, r.lods.length, r);
    }
  }
}
function mt(a, t, e, s) {
  Be(t), Ie(e), e.register((r) => new _(r, a));
  const n = G.get(t);
  return (s == null ? void 0 : s.enableLODsManager) !== !1 && n.enable(), n;
}
ke();
export {
  V as EXTENSION_NAME,
  G as LODsManager,
  _ as NEEDLE_progressive,
  Ce as VERSION,
  Ie as addDracoAndKTX2Loaders,
  Be as createLoaders,
  me as getRaycastMesh,
  ke as patchModelViewer,
  et as registerRaycastMesh,
  gt as setDracoDecoderLocation,
  pt as setKTX2TranscoderLocation,
  mt as useNeedleProgressive,
  yt as useRaycastMeshes
};

/** The various events that can be dispatched by a Needle Engine {@link IContext} instance
 */
export var ContextEvent;
(function (ContextEvent) {
    /** called when the context is registered to the registry, the context is not fully initialized at this point */
    ContextEvent["ContextRegistered"] = "ContextRegistered";
    /** called before the first glb is loaded, can be used to initialize physics engine, is awaited */
    ContextEvent["ContextCreationStart"] = "ContextCreationStart";
    /** Called when the context has been created, before the first frame */
    ContextEvent["ContextCreated"] = "ContextCreated";
    /** Called after the first frame has been rendered after creation */
    ContextEvent["ContextFirstFrameRendered"] = "ContextFirstFrameRendered";
    /** Called before the context gets destroyed */
    ContextEvent["ContextDestroying"] = "ContextDestroying";
    /** Called when the context has been destroyed */
    ContextEvent["ContextDestroyed"] = "ContextDestroyed";
    /** Called when the context could not find a camera during creation */
    ContextEvent["MissingCamera"] = "MissingCamera";
    /** Called before the context is being cleared (all objects in the scene are being destroyed and state is reset) */
    ContextEvent["ContextClearing"] = "ContextClearing";
    /** Called after the context has been cleared (all objects in the scene have been destroyed and state has been reset) */
    ContextEvent["ContextCleared"] = "ContextCleared";
})(ContextEvent || (ContextEvent = {}));
/** Use to register to various Needle Engine context events and to get access to all current instances
 * e.g. when being created in the DOM
 * @example
 * ```typescript
 * import { NeedleEngine } from "./engine/engine_context_registry.js";
 * NeedleEngine.addContextCreatedCallback((evt) => {
 *    console.log("Context created", evt.context);
 * });
 * ```
 * */
export class ContextRegistry {
    /** The currently active (rendering) Needle Engine context */
    static get Current() {
        return globalThis["NeedleEngine.Context.Current"];
    }
    /** @internal */
    static set Current(ctx) {
        globalThis["NeedleEngine.Context.Current"] = ctx;
    }
    /** Returns the array of all registered Needle Engine contexts. Do not modify */
    static get All() {
        return this.Registered;
    }
    /** All currently registered Needle Engine contexts. Do not modify */
    static Registered = [];
    /** @internal Internal use only */
    static register(ctx) {
        this.Registered.push(ctx);
        this.dispatchCallback(ContextEvent.ContextRegistered, ctx);
    }
    /** @internal Internal use only */
    static unregister(ctx) {
        const index = this.Registered.indexOf(ctx);
        if (index === -1)
            return;
        this.Registered.splice(index, 1);
    }
    static _callbacks = {};
    /**
     * Register a callback to be called when the given event occurs
     */
    static registerCallback(evt, callback) {
        if (!this._callbacks[evt])
            this._callbacks[evt] = [];
        this._callbacks[evt].push(callback);
    }
    /** Unregister a callback */
    static unregisterCallback(evt, callback) {
        if (!this._callbacks[evt])
            return;
        const index = this._callbacks[evt].indexOf(callback);
        if (index === -1)
            return;
        this._callbacks[evt].splice(index, 1);
    }
    /** @internal */
    static dispatchCallback(evt, context, extras) {
        if (!this._callbacks[evt])
            return true;
        const cbArgs = { event: evt, context };
        if (extras) {
            for (const key in extras) {
                cbArgs[key] = extras[key];
            }
        }
        const promises = new Array();
        this._callbacks[evt].forEach(cb => {
            const res = cb(cbArgs);
            if (res instanceof Promise)
                promises.push(res);
        });
        return Promise.all(promises);
    }
    /**
     * Register a callback to be called when a context is created
     */
    static addContextCreatedCallback(callback) {
        this.registerCallback(ContextEvent.ContextCreated, callback);
    }
    /**
     * Register a callback to be called when a context is registered
     */
    static addContextDestroyedCallback(callback) {
        this.registerCallback(ContextEvent.ContextDestroyed, callback);
    }
}
export { ContextRegistry as NeedleEngine };
//# sourceMappingURL=engine_context_registry.js.map
const defaultNetworkingBackendUrlProvider = "https://urls.needle.tools/default-networking-backend/index";
let serverUrl = "wss://needle-tiny-starter.glitch.me/socket";
import * as flatbuffers from 'flatbuffers';
import * as schemes from "../engine-schemes/schemes.js";
import { isDevEnvironment } from './debug/index.js';
import { PeerNetworking } from './engine_networking_peer.js';
import { SendQueue } from './engine_networking_types.js';
import { isHostedOnGlitch } from './engine_networking_utils.js';
import * as utils from "./engine_utils.js";
export const debugNet = utils.getParam("debugnet") ? true : false;
export const debugOwner = debugNet || utils.getParam("debugowner") ? true : false;
const debugnetBin = utils.getParam("debugnetbin");
/** Events regarding the websocket connection (e.g. when the connection opens) */
export var ConnectionEvents;
(function (ConnectionEvents) {
    ConnectionEvents["ConnectionInfo"] = "connection-start-info";
})(ConnectionEvents || (ConnectionEvents = {}));
/** Use to listen to room networking events like joining a networked room
 *  For example: `this.context.connection.beginListen(RoomEvents.JoinedRoom, () => { })`
 * @link https://engine.needle.tools/docs/networking.html#manual-networking
 * */
export var RoomEvents;
(function (RoomEvents) {
    /** Internal: sent to the server when attempting to join a room */
    RoomEvents["Join"] = "join-room";
    /** Internal: sent to the server when attempting to leave a room */
    RoomEvents["Leave"] = "leave-room";
    /** Incoming: When the local user has joined a room */
    RoomEvents["JoinedRoom"] = "joined-room";
    /** Incoming: When the local user has left a room */
    RoomEvents["LeftRoom"] = "left-room";
    /** Incoming: When a other user has joined the room */
    RoomEvents["UserJoinedRoom"] = "user-joined-room";
    /** Incoming: When a other user has left the room */
    RoomEvents["UserLeftRoom"] = "user-left-room";
    RoomEvents["RoomStateSent"] = "room-state-sent";
})(RoomEvents || (RoomEvents = {}));
/** Received when listening to `RoomEvents.JoinedRoom` event */
export class JoinedRoomResponse {
    room; // room name
    viewId;
    allowEditing;
    inRoom; // connection ids
}
export class LeftRoomResponse {
    room; // room name
}
export class UserJoinedOrLeftRoomModel {
    userId;
}
/** The Needle Engine networking server supports the concept of ownership that can be requested.
 * This enum contains possible outgoing (Request*) and incoming (Response*) events for communicating ownership.
 *
 * Typically, using the {@link OwnershipModel} class instead of dealing with those events directly is preferred. */
export var OwnershipEvent;
(function (OwnershipEvent) {
    OwnershipEvent["RequestHasOwner"] = "request-has-owner";
    OwnershipEvent["ResponseHasOwner"] = "response-has-owner";
    OwnershipEvent["RequestIsOwner"] = "request-is-owner";
    OwnershipEvent["ResponseIsOwner"] = "response-is-owner";
    OwnershipEvent["RequestOwnership"] = "request-ownership";
    OwnershipEvent["GainedOwnership"] = "gained-ownership";
    OwnershipEvent["RemoveOwnership"] = "remove-ownership";
    OwnershipEvent["LostOwnership"] = "lost-ownership";
    OwnershipEvent["GainedOwnershipBroadcast"] = "gained-ownership-broadcast";
    OwnershipEvent["LostOwnershipBroadcast"] = "lost-ownership-broadcast";
})(OwnershipEvent || (OwnershipEvent = {}));
/** Class for abstracting the concept of ownership regarding a networked object or component.
 * A component that is owned by another user can not be modified through networking (the server will reject changes) */
export class OwnershipModel {
    guid;
    connection;
    get hasOwnership() {
        return this._hasOwnership;
    }
    // TODO: server should just send id to everyone
    // if anyone has ownership
    get isOwned() {
        return this._isOwned;
    }
    get isConnected() {
        return this.connection.isConnected;
    }
    _hasOwnership = false;
    _isOwned = undefined;
    _gainSubscription;
    _lostSubscription;
    _hasOwnerResponse;
    constructor(connection, guid) {
        this.connection = connection;
        this.guid = guid;
        this._gainSubscription = this.onGainedOwnership.bind(this);
        this._lostSubscription = this.onLostOwnership.bind(this);
        connection.beginListen(OwnershipEvent.LostOwnership, this._lostSubscription);
        connection.beginListen(OwnershipEvent.GainedOwnershipBroadcast, this._gainSubscription);
        this._hasOwnerResponse = this.onHasOwnerResponse.bind(this);
        connection.beginListen(OwnershipEvent.ResponseHasOwner, this._hasOwnerResponse);
    }
    _isWaitingForOwnershipResponseCallback = null;
    updateIsOwned() {
        this.connection.send(OwnershipEvent.RequestHasOwner, { guid: this.guid });
    }
    onHasOwnerResponse(res) {
        if (res.guid === this.guid) {
            this._isOwned = res.value;
        }
    }
    requestOwnershipIfNotOwned() {
        if (this._isWaitingForOwnershipResponseCallback !== null)
            return this;
        this._isWaitingForOwnershipResponseCallback = this.waitForHasOwnershipRequestResponse.bind(this);
        this.connection.beginListen(OwnershipEvent.ResponseHasOwner, this._isWaitingForOwnershipResponseCallback);
        this.connection.send(OwnershipEvent.RequestHasOwner, { guid: this.guid });
        return this;
    }
    waitForHasOwnershipRequestResponse(res) {
        // console.log(res);
        if (res.guid === this.guid) {
            if (this._isWaitingForOwnershipResponseCallback) {
                this.connection.stopListen(OwnershipEvent.ResponseHasOwner, this._isWaitingForOwnershipResponseCallback);
                this._isWaitingForOwnershipResponseCallback = null;
            }
            this._isOwned = res.value;
            if (!res.value) {
                if (debugOwner)
                    console.log("request ownership", this.guid);
                this.requestOwnership();
            }
        }
    }
    requestOwnershipAsync() {
        return new Promise((resolve, reject) => {
            this.requestOwnership();
            let updates = 0;
            const waitForOwnership = () => {
                if (updates++ > 10)
                    return reject("Timeout");
                setTimeout(() => {
                    if (this.hasOwnership)
                        resolve(this);
                    else
                        waitForOwnership();
                }, 100);
            };
            waitForOwnership();
        });
    }
    requestOwnership() {
        if (debugOwner)
            console.log("Request ownership", this.guid);
        this.connection.send(OwnershipEvent.RequestOwnership, { guid: this.guid });
        return this;
    }
    freeOwnership() {
        // TODO: abort "requestOwnershipIfNotOwned"
        this.connection.send(OwnershipEvent.RemoveOwnership, { guid: this.guid });
        if (this._isWaitingForOwnershipResponseCallback) {
            this.connection.stopListen(OwnershipEvent.ResponseHasOwner, this._isWaitingForOwnershipResponseCallback);
            this._isWaitingForOwnershipResponseCallback = null;
        }
        return this;
    }
    destroy() {
        this.connection.stopListen(OwnershipEvent.GainedOwnership, this._gainSubscription);
        this.connection.stopListen(OwnershipEvent.LostOwnership, this._lostSubscription);
        this.connection.stopListen(OwnershipEvent.ResponseHasOwner, this._hasOwnerResponse);
        if (this._isWaitingForOwnershipResponseCallback) {
            this.connection.stopListen(OwnershipEvent.ResponseHasOwner, this._isWaitingForOwnershipResponseCallback);
            this._isWaitingForOwnershipResponseCallback = null;
        }
    }
    onGainedOwnership(res) {
        if (res.guid === this.guid) {
            this._isOwned = true;
            // console.log(res.owner, connection.connectionId)
            if (this.connection.connectionId === res.owner) {
                if (debugOwner)
                    console.log("GAINED OWNERSHIP", this.guid);
                this._hasOwnership = true;
            }
            else
                this._hasOwnership = false;
        }
    }
    onLostOwnership(guid) {
        if (guid === this.guid) {
            if (debugOwner)
                console.log("LOST OWNERSHIP", this.guid);
            this._hasOwnership = false;
            this._isOwned = false;
        }
    }
}
/** Main class to communicate with the networking backend */
export class NetworkConnection {
    context;
    _peer = null;
    constructor(context) {
        this.context = context;
    }
    /** Experimental: networking via peerjs */
    get peer() {
        if (!this._peer) {
            this._peer = new PeerNetworking();
        }
        return this._peer;
    }
    /**
     * Returns the state of a given guid.
     */
    tryGetState(guid) {
        if (guid === "invalid")
            return null;
        return this._state[guid];
    }
    /** The connection id of the local user - it is given by the networking backend and can not be changed */
    get connectionId() {
        return this._connectionId;
    }
    get isDebugEnabled() {
        return debugNet;
    }
    /** True when connected to the networking backend */
    get isConnected() {
        return this.connected;
    }
    /** The name of the room the user is currently connected to */
    get currentRoomName() { return this._currentRoomName; }
    /** True when connected to a room via a regular url, otherwise (when using a view only url) false indicating that the user should not be able to modify the scene */
    get allowEditing() { return this._currentRoomAllowEditing; }
    /**
     * The view id of the room the user is currently connected to.
     */
    get currentRoomViewId() { return this._currentRoomViewId; }
    /**
     * Returns a url that can be shared with others to view the current room in view only mode.
     * This is useful for sharing a room with others without allowing them to modify the scene.
     * Use `connection.allowEditing` to check if the current room is in view only mode.
     */
    getViewOnlyUrl() {
        if (this.currentRoomViewId === null)
            return null;
        const url = new URL(window.location.href);
        url.searchParams.set("view", this.currentRoomViewId);
        return url.href;
    }
    /** True if connected to a networked room. Use the joinRoom function or a `SyncedRoom` component */
    get isInRoom() {
        return this._isInRoom;
    }
    /** Latency to currently connected backend server */
    get currentLatency() {
        return this._currentDelay;
    }
    /**
     * The current server url that the networking backend is connected to (e.g. the url of the websocket server)
     */
    get currentServerUrl() {
        // @ts-ignore (in ts-websocket 2.x this property is exposed)
        return this._ws?.url ?? null;
    }
    /** A ping is sent to the server at a regular interval while the browser tab is active. This method can be used to send additional ping messages when needed so that the user doesn't get disconnected from the networking backend */
    sendPing() {
        this.send("ping", { time: this.context.time.time });
    }
    /** Returns true if a user with the given connectionId is in the room */
    userIsInRoom(id) {
        return this._currentInRoom.indexOf(id) !== -1;
    }
    _usersInRoomCopy = [];
    /** Returns a list of all user ids in the current room */
    usersInRoom(target = null) {
        if (!target)
            target = this._usersInRoomCopy;
        target.length = 0;
        for (const user of this._currentInRoom)
            target.push(user);
        return target;
    }
    /** Joins a networked room. If you don't want to manage a connection yourself you can use a `SyncedRoom` component as well */
    joinRoom(room, viewOnly = false) {
        if (!room) {
            console.error("Missing room name, can not join: \"" + room + "\"");
            return false;
        }
        // There's not really a reason to limit the room name length
        if (room.length > 1024) {
            console.error("Room name too long, can not join: \"" + room + "\". Max length is 1024 characters.");
            return false;
        }
        this.connect();
        if (debugNet)
            console.log("join: " + room);
        this.send(RoomEvents.Join, { room: room, viewOnly: viewOnly }, SendQueue.OnConnection);
        return true;
    }
    /** Use to leave a room that you are currently connected to (use `leaveRoom()` to disconnect from the currently active room but you can also specify a room name) */
    leaveRoom(room = null) {
        if (!room)
            room = this.currentRoomName;
        if (!room) {
            console.error("Missing room name, can not join: \"" + room + "\"");
            return false;
        }
        this.send(RoomEvents.Leave, { room: room });
        return true;
    }
    /** Send a message to the networking backend - it will broadcasted to all connected users in the same room by default */
    send(key, data = null, queue = SendQueue.Queued) {
        //@ts-ignore
        if (data === null)
            data = {};
        if (queue === SendQueue.Queued) {
            this._defaultMessagesBuffer.push({ key: key, value: data });
            return;
        }
        // if (!this.connected) return;
        // if (this.channelId)
        //     data["__id"] = this.channelId;
        // else if (this.connectionId)
        //     data["__id"] = this.connectionId;
        // this.sendGeckosIo(key, data);
        return this.sendWithWebsocket(key, data, queue);
    }
    /** Use to delete state for a given guid on the server */
    sendDeleteRemoteState(guid) {
        this.send("delete-state", { guid: guid, dontSave: true });
        delete this._state[guid];
    }
    /** Use to delete all state in the currently connected room on the server */
    sendDeleteRemoteStateAll() {
        this.send("delete-all-state");
        this._state = {};
    }
    /** Send a binary message to the server (broadcasted to all connected users) */
    sendBinary(bin) {
        if (debugnetBin)
            console.log("<< send binary", this.context.time.frame, (bin.length / 1024) + " KB");
        this._ws?.send(bin);
    }
    _defaultMessagesBuffer = [];
    _defaultMessagesBufferArray = [];
    sendBufferedMessagesNow() {
        if (!this._ws)
            return;
        this._defaultMessagesBufferArray.length = 0;
        const count = Object.keys(this._defaultMessagesBuffer).length;
        for (const key in this._defaultMessagesBuffer) {
            const data = this._defaultMessagesBuffer[key];
            // if there is only one message to be sent we dont need to send an array
            if (count <= 1) {
                this.sendWithWebsocket(data.key, data.value, SendQueue.Immediate);
                break;
            }
            const msg = this.toMessage(data.key, data.value);
            this._defaultMessagesBufferArray.push(msg);
        }
        this._defaultMessagesBuffer.length = 0;
        if (this._defaultMessagesBufferArray.length > 0 && debugNet)
            console.log("SEND BUFFERED", this._defaultMessagesBufferArray.length);
        if (this._defaultMessagesBufferArray.length <= 0)
            return;
        const message = JSON.stringify(this._defaultMessagesBufferArray);
        this._ws?.send(message);
    }
    /** Use to start listening to networking events */
    beginListen(key, callback) {
        if (!this._listeners[key])
            this._listeners[key] = [];
        this._listeners[key].push(callback);
        return callback;
    }
    /**@deprecated please use stopListen instead (2.65.2-pre) */
    stopListening(key, callback) { return this.stopListen(key, callback); }
    /** Use to stop listening to networking events */
    stopListen(key, callback) {
        if (!callback)
            return;
        if (!this._listeners[key])
            return;
        const index = this._listeners[key].indexOf(callback);
        if (index >= 0) {
            this._listeners[key].splice(index, 1);
        }
    }
    /** Use to start listening to networking binary events */
    beginListenBinary(identifier, callback) {
        if (!this._listenersBinary[identifier])
            this._listenersBinary[identifier] = [];
        this._listenersBinary[identifier].push(callback);
        return callback;
    }
    /** Use to stop listening to networking binary events */
    stopListenBinary(identifier, callback) {
        if (!this._listenersBinary[identifier])
            return;
        const index = this._listenersBinary[identifier].indexOf(callback);
        if (index >= 0) {
            this._listenersBinary[identifier].splice(index, 1);
        }
    }
    netWebSocketUrlProvider;
    /** Use to override the networking server backend url. This is what the `Networking` component uses to modify the backend url */
    registerProvider(prov) {
        this.netWebSocketUrlProvider = prov;
    }
    /** Used to connect to the networking server */
    async connect() {
        if (this.connected)
            return Promise.resolve(true);
        if (debugNet)
            console.log("connecting");
        const overrideUrl = this.netWebSocketUrlProvider?.getWebsocketUrl();
        if (overrideUrl) {
            serverUrl = overrideUrl;
        }
        else if (isHostedOnGlitch()) {
            serverUrl = "wss://" + window.location.host + "/socket";
        }
        return this.connectWebsocket();
    }
    ;
    /** Used to disconnect from the networking server */
    disconnect() {
        this._ws?.close();
        this._ws = undefined;
    }
    _listeners = {};
    _listenersBinary = {};
    connected = false;
    channelId;
    _connectionId = null;
    // Websocket ------------------------------------------------------------
    _ws;
    _waitingForSocket = {};
    _isInRoom = false;
    _currentRoomName = null;
    _currentRoomViewId = null;
    _currentRoomAllowEditing = true;
    _currentInRoom = [];
    _state = {};
    _currentDelay = -1;
    _connectingToWebsocketPromise = null;
    connectWebsocket() {
        if (this._connectingToWebsocketPromise)
            return this._connectingToWebsocketPromise;
        return this._connectingToWebsocketPromise = new Promise(async (res, _) => {
            let didResolve = false;
            const resolve = (val) => {
                if (didResolve)
                    return;
                didResolve = true;
                res(val);
            };
            if (serverUrl === undefined) {
                console.log("Fetch default backend url: " + defaultNetworkingBackendUrlProvider);
                const failed = false;
                const defaultUrlResponse = await fetch(defaultNetworkingBackendUrlProvider);
                serverUrl = await defaultUrlResponse.text();
                if (failed)
                    return;
            }
            if (serverUrl === undefined) {
                resolve(false);
                return;
            }
            console.debug("⊡ Connecting to networking backend on\n" + serverUrl);
            const pkg = await import('websocket-ts');
            // @ts-ignore
            const WebsocketBuilder = pkg.default?.WebsocketBuilder ?? pkg.WebsocketBuilder;
            const ExponentialBackoff = pkg.default?.ExponentialBackoff ?? pkg.ExponentialBackoff;
            const ws = new WebsocketBuilder(serverUrl)
                .withMaxRetries(3)
                .withBackoff(new ExponentialBackoff(2000, 2))
                .onOpen(() => {
                this._connectingToWebsocketPromise = null;
                this._ws = ws;
                this.connected = true;
                if (isDevEnvironment() || debugNet)
                    console.log("⊞ Connected to networking backend\n" + serverUrl);
                else
                    console.debug("⊞ Connected to networking backend", serverUrl);
                resolve(true);
                this.onSendQueued(SendQueue.OnConnection);
            })
                .onClose((_evt) => {
                this._connectingToWebsocketPromise = null;
                this.connected = false;
                this._isInRoom = false;
                resolve(false);
            })
                .onError((_) => {
                console.error("⊠ Websocket error");
                resolve(false);
            })
                .onRetry(() => { console.log("Retry connecting to networking websocket"); })
                .build();
            ws.addEventListener(pkg.WebsocketEvent.message, (socket, msg) => {
                this.onMessage(socket, msg);
            });
        });
    }
    onMessage(_, ev) {
        const msg = ev.data;
        try {
            if (typeof msg !== "string") {
                if (msg.size) {
                    // is binary blob
                    this.handleIncomingBinaryMessage(msg);
                }
                return;
            }
            const message = JSON.parse(msg);
            if (Array.isArray(message)) {
                // console.log("Receive package of " + message.length + " messages")
                for (const msg of message) {
                    this.handleIncomingStringMessage(msg);
                }
            }
            else
                this.handleIncomingStringMessage(message);
            return;
        }
        catch (err) {
            if (debugNet && msg === "pong")
                console.log("<<", msg);
            else if (isDevEnvironment())
                console.error("Failed to parse message", err);
        }
    }
    async handleIncomingBinaryMessage(blob) {
        if (debugnetBin)
            console.log("<< bin", this.context.time.frame);
        const buf = await blob.arrayBuffer();
        var data = new Uint8Array(buf);
        const bb = new flatbuffers.ByteBuffer(data);
        const id = bb.getBufferIdentifier();
        const callbacks = this._listenersBinary[id];
        // use registered cast methods to get the correct type from the flatbuffer
        const obj = schemes.tryCastBinary(bb);
        const guid = schemes.tryGetGuid(obj);
        if (guid && typeof guid === "string") {
            this._state[guid] = obj;
        }
        if (!callbacks)
            return;
        const res = obj ?? bb; // fallback to bytebuffer if no cast method is registered
        // call all listeners subscribed to these events
        for (const cb of callbacks) {
            cb(res);
        }
    }
    handleIncomingStringMessage(message) {
        if (debugNet)
            console.log("<<", message.key ?? message);
        if (message.key) {
            switch (message.key) {
                case ConnectionEvents.ConnectionInfo:
                    if (message.data) {
                        const connection = message.data;
                        if (connection) {
                            console.assert(connection.id !== undefined && connection.id !== null && connection.id.length > 0, "server did not send connection id", connection.id);
                            console.debug("Your id is: " + connection.id, this.context.alias ?? "");
                            this._connectionId = connection.id;
                        }
                    }
                    else
                        console.warn("Expected connection id in " + message.key);
                    break;
                case RoomEvents.JoinedRoom:
                    if (debugNet)
                        console.log(message);
                    if (message) {
                        this._isInRoom = true;
                        const model = message;
                        this._currentRoomName = model.room;
                        this._currentRoomViewId = model.viewId;
                        this._currentRoomAllowEditing = model.allowEditing ?? true;
                        this._currentInRoom.length = 0;
                        this._currentInRoom.push(...model.inRoom);
                        if (debugnetBin || isDevEnvironment())
                            console.debug("Joined Needle Engine Room: " + model.room);
                        const viewUrl = new URL(window.location.href);
                        if (viewUrl.searchParams.has("room")) {
                            viewUrl.searchParams.delete("room");
                        }
                        viewUrl.searchParams.set("view", this._currentRoomViewId);
                        console.debug(`Room view id: ${this._currentRoomViewId}\n${viewUrl.href}`);
                    }
                    this.onSendQueued(SendQueue.OnRoomJoin);
                    break;
                case RoomEvents.LeftRoom:
                    const model = message;
                    if (model.room === this.currentRoomName) {
                        this._isInRoom = false;
                        this._currentRoomName = null;
                        this._currentInRoom.length = 0;
                    }
                    break;
                case RoomEvents.UserJoinedRoom:
                    if (message.data) {
                        const model = message.data;
                        this._currentInRoom.push(model.userId);
                        if (debugNet)
                            console.log(model.userId + " joined", "now in room:", this._currentInRoom);
                    }
                    break;
                case RoomEvents.UserLeftRoom:
                    if (message.data) {
                        const model = message.data;
                        const index = this._currentInRoom.indexOf(model.userId);
                        if (index >= 0) {
                            if (debugNet)
                                console.log(model.userId + " left", "now in room:", this._currentInRoom);
                            this._currentInRoom.splice(index, 1);
                        }
                        if (model.userId === this.connectionId) {
                            // you left the room
                            console.log("you left the room");
                        }
                    }
                    break;
                case "all-room-state-deleted":
                    if (debugNet)
                        console.log("RECEIVED all-room-state-deleted");
                    this._state = {};
                    break;
                case "ping":
                case "pong":
                    const time = message.data?.time;
                    if (time) {
                        this._currentDelay = this.context.time.time - time;
                    }
                    if (debugNet)
                        console.log("Current latency: " + this._currentDelay.toFixed(4) + " sec", "Clients in room: " + this._currentInRoom?.length);
                    break;
            }
        }
        const model = message.data;
        if (model) {
            this._state[model.guid] = model;
        }
        let listeners = this._listeners[message.key];
        if (listeners) {
            // Copy listeners array in case a listener is removed while iterating
            listeners = [...listeners];
            for (const listener of listeners) {
                try {
                    listener(message.data);
                }
                catch (err) {
                    console.error("Error invoking callback for \"" + message.key + "\"", err);
                }
            }
        }
    }
    toMessage(key, data) {
        return {
            key: key,
            data: data
        };
    }
    sendWithWebsocket(key, data, queue = SendQueue.OnRoomJoin) {
        // console.log(key);
        if (!this._ws) {
            const arr = this._waitingForSocket[queue] || [];
            arr.push(() => this.sendWithWebsocket(key, data, queue));
            this._waitingForSocket[queue] = arr;
            // console.log(this._bufferedMessages)
            return;
        }
        const str = JSON.stringify(this.toMessage(key, data));
        if (debugNet)
            console.log(">>", key);
        this._ws.send(str);
    }
    onSendQueued(queue) {
        const queued = this._waitingForSocket[queue];
        // console.log("send", queue, queued);
        if (queued) {
            for (const callback of queued) {
                callback();
            }
            queued.length = 0;
        }
    }
}
//# sourceMappingURL=engine_networking.js.map
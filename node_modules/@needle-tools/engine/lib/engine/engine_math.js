class MathHelper {
    random(arrayOrMin, max) {
        if (Array.isArray(arrayOrMin)) {
            if (arrayOrMin.length <= 0)
                return null;
            return arrayOrMin[Math.floor(Math.random() * arrayOrMin.length)];
        }
        else {
            if (arrayOrMin !== undefined && max !== undefined) {
                return Math.random() * (max - arrayOrMin) + arrayOrMin;
            }
        }
        return Math.random();
    }
    randomVector3(target, min = 0, max = 1) {
        target.x = this.random(min, max);
        target.y = this.random(min, max);
        target.z = this.random(min, max);
    }
    clamp(value, min, max) {
        if (value < min) {
            return min;
        }
        else if (value > max) {
            return max;
        }
        return value;
    }
    clamp01(value) {
        return this.clamp(value, 0, 1);
    }
    lerp(value1, value2, t) {
        t = t < 0 ? 0 : t;
        t = t > 1 ? 1 : t;
        return value1 + (value2 - value1) * t;
    }
    inverseLerp(value1, value2, t) {
        return (t - value1) / (value2 - value1);
    }
    remap(value, min1, max1, min2, max2) {
        return min2 + (max2 - min2) * (value - min1) / (max1 - min1);
    }
    moveTowards(value1, value2, amount) {
        value1 += amount;
        if (amount < 0 && value1 < value2)
            value1 = value2;
        else if (amount > 0 && value1 > value2)
            value1 = value2;
        return value1;
    }
    toDegrees(radians) {
        return radians * 180 / Math.PI;
    }
    Rad2Deg = 180 / Math.PI;
    toRadians(degrees) {
        return degrees * Math.PI / 180;
    }
    Deg2Rad = Math.PI / 180;
    Epsilon = 0.00001;
    tan(radians) {
        return Math.tan(radians);
    }
    gammaToLinear(gamma) {
        return Math.pow(gamma, 2.2);
    }
    linearToGamma(linear) {
        return Math.pow(linear, 1 / 2.2);
    }
    approximately(v1, v2, epsilon = Number.EPSILON) {
        for (const key of vectorKeys) {
            const a = v1[key];
            const b = v2[key];
            if (a === undefined || b === undefined)
                break;
            const diff = Math.abs(a - b);
            if (diff > epsilon) {
                return false;
            }
        }
        return true;
    }
    easeInOutCubic(x) {
        return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
    }
}
;
const vectorKeys = ["x", "y", "z", "w"];
export const Mathf = new MathHelper();
class LowPassFilter {
    y;
    s;
    alpha = 0;
    constructor(alpha) {
        this.setAlpha(alpha);
        this.y = null;
        this.s = null;
    }
    setAlpha(alpha) {
        if (alpha <= 0 || alpha > 1.0) {
            throw new Error();
        }
        this.alpha = alpha;
    }
    filter(value, alpha) {
        if (alpha) {
            this.setAlpha(alpha);
        }
        let s;
        if (!this.y) {
            s = value;
        }
        else {
            s = this.alpha * value + (1.0 - this.alpha) * this.s;
        }
        this.y = value;
        this.s = s;
        return s;
    }
    lastValue() {
        return this.y;
    }
    reset(value) {
        this.y = value;
        this.s = value;
    }
}
/**
 * OneEuroFilter is a simple low-pass filter for noisy signals. It uses a one-euro filter to smooth the signal.
 */
export class OneEuroFilter {
    /**
     * An estimate of the frequency in Hz of the signal (> 0), if timestamps are not available.
     */
    freq;
    /**
     * Min cutoff frequency in Hz (> 0). Lower values allow to remove more jitter.
     */
    minCutOff;
    /**
     * Parameter to reduce latency (> 0). Higher values make the filter react faster to changes.
     */
    beta;
    /**
     * Used to filter the derivates. 1 Hz by default. Change this parameter if you know what you are doing.
     */
    dCutOff;
    /**
     * The low-pass filter for the signal.
     */
    x;
    /**
     * The low-pass filter for the derivates.
     */
    dx;
    /**
     * The last time the filter was called.
     */
    lasttime;
    /** Create a new OneEuroFilter
     * @param freq - An estimate of the frequency in Hz of the signal (> 0), if timestamps are not available.
     * @param minCutOff - Min cutoff frequency in Hz (> 0). Lower values allow to remove more jitter.
     * @param beta - Parameter to reduce latency (> 0). Higher values make the filter react faster to changes.
     * @param dCutOff - Used to filter the derivates. 1 Hz by default. Change this parameter if you know what you are doing.
     */
    constructor(freq, minCutOff = 1.0, beta = 0.0, dCutOff = 1.0) {
        if (freq <= 0 || minCutOff <= 0 || dCutOff <= 0) {
            throw new Error();
        }
        this.freq = freq;
        this.minCutOff = minCutOff;
        this.beta = beta;
        this.dCutOff = dCutOff;
        this.x = new LowPassFilter(this.alpha(this.minCutOff));
        this.dx = new LowPassFilter(this.alpha(this.dCutOff));
        this.lasttime = null;
    }
    alpha(cutOff) {
        const te = 1.0 / this.freq;
        const tau = 1.0 / (2 * Math.PI * cutOff);
        return 1.0 / (1.0 + tau / te);
    }
    /** Filter your value: call with your value and the current timestamp (e.g. from this.context.time.time) */
    filter(x, time = null) {
        if (this.lasttime && time) {
            this.freq = 1.0 / (time - this.lasttime);
        }
        this.lasttime = time;
        const prevX = this.x.lastValue();
        const dx = !prevX ? 0.0 : (x - prevX) * this.freq;
        const edx = this.dx.filter(dx, this.alpha(this.dCutOff));
        const cutOff = this.minCutOff + this.beta * Math.abs(edx);
        return this.x.filter(x, this.alpha(cutOff));
    }
    reset(x) {
        if (x != undefined)
            this.x.reset(x);
        this.x.alpha = this.alpha(this.minCutOff);
        this.dx.alpha = this.alpha(this.dCutOff);
        this.lasttime = null;
    }
}
export class OneEuroFilterXYZ {
    x;
    y;
    z;
    /** Create a new OneEuroFilter
     * @param freq - An estimate of the frequency in Hz of the signal (> 0), if timestamps are not available.
     * @param minCutOff - Min cutoff frequency in Hz (> 0). Lower values allow to remove more jitter.
     * @param beta - Parameter to reduce latency (> 0). Higher values make the filter react faster to changes.
     * @param dCutOff - Used to filter the derivates. 1 Hz by default. Change this parameter if you know what you are doing.
     */
    constructor(freq, minCutOff = 1.0, beta = 0.0, dCutOff = 1.0) {
        this.x = new OneEuroFilter(freq, minCutOff, beta, dCutOff);
        this.y = new OneEuroFilter(freq, minCutOff, beta, dCutOff);
        this.z = new OneEuroFilter(freq, minCutOff, beta, dCutOff);
    }
    filter(value, target, time = null) {
        target.x = this.x.filter(value.x, time);
        target.y = this.y.filter(value.y, time);
        target.z = this.z.filter(value.z, time);
    }
    reset(value) {
        this.x.reset(value?.x);
        this.y.reset(value?.y);
        this.z.reset(value?.z);
    }
}
//# sourceMappingURL=engine_math.js.map
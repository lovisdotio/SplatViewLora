import { QueryFilterFlags, World } from '@dimforge/rapier3d-compat';
import { Mesh, Vector3 } from 'three';
import type { ICollider, IComponent, IContext, IPhysicsEngine, IRigidbody, Vec2, Vec3 } from './engine_types.js';
import { SphereOverlapResult } from './engine_types.js';
export declare class RapierPhysics implements IPhysicsEngine {
    debugRenderColliders: boolean;
    debugRenderRaycasts: boolean;
    removeBody(obj: IComponent): void;
    updateBody(comp: ICollider | IRigidbody, translation: boolean, rotation: boolean): void;
    updateProperties(obj: IRigidbody | ICollider): void;
    addForce(rigidbody: IRigidbody, force: Vec3, wakeup: boolean): void;
    addImpulse(rigidbody: IRigidbody, force: Vec3, wakeup: boolean): void;
    getLinearVelocity(comp: IRigidbody | ICollider): Vec3 | null;
    getAngularVelocity(rb: IRigidbody): Vec3 | null;
    resetForces(rb: IRigidbody, wakeup: boolean): void;
    resetTorques(rb: IRigidbody, wakeup: boolean): void;
    applyImpulse(rb: IRigidbody, vec: Vec3, wakeup: boolean): void;
    wakeup(rb: IRigidbody): void;
    isSleeping(rb: IRigidbody): boolean | undefined;
    setAngularVelocity(rb: IRigidbody, vec: Vec3, wakeup: boolean): void;
    setLinearVelocity(rb: IRigidbody, vec: Vec3, wakeup: boolean): void;
    private context?;
    private _initializePromise?;
    private _isInitialized;
    initialize(context: IContext): Promise<boolean>;
    private internalInitialization;
    /** Check is the physics engine has been initialized and the call can be made */
    private validate;
    private rapierRay;
    private raycastVectorsBuffer;
    raycast(origin?: Vec2 | Vec3, direction?: Vec3, options?: {
        maxDistance?: number;
        /** True if you want to also hit objects when the raycast starts from inside a collider */
        solid?: boolean;
        queryFilterFlags?: QueryFilterFlags;
        filterGroups?: number;
        /** Return false to ignore this collider */
        filterPredicate?: (c: ICollider) => boolean;
        /** When enabled the hit object's layer will be tested. If layer 2 is enabled the object will be ignored (Layer 2 == IgnoreRaycast)
         * If not set the raycast will ignore objects in the IgnoreRaycast layer (default: true)
         * @default undefined
        */
        useIgnoreRaycastLayer?: boolean;
    }): null | {
        point: Vector3;
        collider: ICollider;
    };
    raycastAndGetNormal(origin?: Vec2 | Vec3, direction?: Vec3, options?: {
        maxDistance?: number;
        /** True if you want to also hit objects when the raycast starts from inside a collider */
        solid?: boolean;
        queryFilterFlags?: QueryFilterFlags;
        filterGroups?: number;
        /** Return false to ignore this collider */
        filterPredicate?: (c: ICollider) => boolean;
        /** When enabled the hit object's layer will be tested. If layer 2 is enabled the object will be ignored (Layer 2 == IgnoreRaycast)
         * If not set the raycast will ignore objects in the IgnoreRaycast layer (default: true)
         * @default undefined
        */
        useIgnoreRaycastLayer?: boolean;
    }): null | {
        point: Vector3;
        normal: Vector3;
        collider: ICollider;
    };
    private getPhysicsRay;
    private rapierSphere;
    private rapierColliderArray;
    private readonly rapierIdentityRotation;
    private readonly rapierForwardVector;
    /** Precice sphere overlap detection using rapier against colliders
     * @param point center of the sphere in worldspace
     * @param radius radius of the sphere
     * @returns array of colliders that overlap with the sphere. Note: they currently only contain the collider and the gameobject
     */
    sphereOverlap(point: Vector3, radius: number): Array<SphereOverlapResult>;
    enabled: boolean;
    /** Get access to the rapier world */
    get world(): World | undefined;
    private _tempPosition;
    private _tempQuaternion;
    private _tempScale;
    private _tempMatrix;
    private static _didLoadPhysicsEngine;
    private _isUpdatingPhysicsWorld;
    get isUpdating(): boolean;
    private _world?;
    private _hasCreatedWorld;
    private eventQueue?;
    private collisionHandler?;
    private objects;
    private bodies;
    private _meshCache;
    private _gravity;
    get gravity(): Vec3;
    set gravity(value: Vec3);
    clearCaches(): void;
    addBoxCollider(collider: ICollider, size: Vector3): Promise<void>;
    addSphereCollider(collider: ICollider): Promise<void>;
    addCapsuleCollider(collider: ICollider, height: number, radius: number): Promise<void>;
    addMeshCollider(collider: ICollider, mesh: Mesh, convex: boolean, scale: Vector3): Promise<void>;
    updatePhysicsMaterial(col: ICollider): void;
    /** Get the rapier body for a Needle component */
    getBody(obj: ICollider | IRigidbody): null | any;
    /** Get the Needle Engine component for a rapier object */
    getComponent(rapierObject: object): IComponent | null;
    private createCollider;
    /**
     * Updates the collision groups of a collider.
     *
     * @param collider - The collider to update.
     */
    private updateColliderCollisionGroups;
    private getRigidbody;
    private internal_getRigidbody;
    private internalUpdateColliderProperties;
    private internalUpdateRigidbodyProperties;
    private lines?;
    step(dt?: number): void;
    postStep(): void;
    private updateDebugRendering;
    /** sync rendered objects with physics world (except for colliders without rigidbody) */
    private syncObjects;
    private syncPhysicsBody;
    private readonly _tempCenterPos;
    private readonly _tempCenterVec;
    private readonly _tempCenterQuaternion;
    private tryApplyCenter;
    private static _matricesBuffer;
    private getRigidbodyRelativeMatrix;
    private static centerConnectionPos;
    private static centerConnectionRot;
    addFixedJoint(body1: IRigidbody, body2: IRigidbody): void;
    /** The joint prevents any relative movement between two rigid-bodies, except for relative rotations along one axis. This is typically used to simulate wheels, fans, etc. They are characterized by one local anchor as well as one local axis on each rigid-body. */
    addHingeJoint(body1: IRigidbody, body2: IRigidbody, anchor: {
        x: number;
        y: number;
        z: number;
    }, axis: {
        x: number;
        y: number;
        z: number;
    }): void;
    private calculateJointRelativeMatrices;
}

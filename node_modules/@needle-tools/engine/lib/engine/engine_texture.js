import { EffectComposer } from "postprocessing";
import { Mesh, WebGLRenderTarget } from "three";
import { findResourceUsers } from "./engine_assetdatabase.js";
const _prevVisible = Symbol("previous-visibility");
/**
 * A RenderTexture can be used to render a scene to a texture automatically by assigning it to the `Camera` component's `targetTexture` property.
 * You can then assign the `RenderTexture.texture` to materials to be displayed
 * @example Create a new RenderTexture and assign it to a camera and material
 * ```typescript
 * // create new RenderTexture with a resolution
 * const rt = new RenderTexture(256, 256);
 * // assign to a camera
 * myCameraComponent.targetTexture = rt;
 * // assign to a material
 * myMaterial.map = rt.texture;
 * ```
 */
export class RenderTexture extends WebGLRenderTarget {
    /**
     * Render the scene to the texture
     * @param scene The scene to render
     * @param camera The camera to render from
     * @param renderer The renderer or effectcomposer to use
     */
    render(scene, camera, renderer) {
        if (renderer instanceof EffectComposer) {
            if (!this["_unsupported_effectcomposer_warning"]) {
                console.warn("RenderTexture.render() does not yet support EffectComposer");
                this["_unsupported_effectcomposer_warning"] = true;
            }
        }
        else {
            this.onBeforeRender();
            const prev = renderer.getRenderTarget();
            const xr = renderer.xr.enabled;
            renderer.xr.enabled = false;
            renderer.setRenderTarget(this);
            renderer.clear(true, true, true);
            renderer.render(scene, camera);
            renderer.setRenderTarget(prev);
            renderer.xr.enabled = xr;
            this.onAfterRender();
        }
    }
    static _userSet = new Set();
    onBeforeRender() {
        RenderTexture._userSet.clear();
        const users = findResourceUsers(this.texture, true, null, RenderTexture._userSet);
        for (const user of users) {
            if (user instanceof Mesh) {
                user[_prevVisible] = user.visible;
                user.visible = false;
            }
        }
    }
    onAfterRender() {
        for (const user of RenderTexture._userSet) {
            if (user instanceof Mesh) {
                user.visible = user[_prevVisible];
            }
        }
        RenderTexture._userSet.clear();
    }
}
//# sourceMappingURL=engine_texture.js.map
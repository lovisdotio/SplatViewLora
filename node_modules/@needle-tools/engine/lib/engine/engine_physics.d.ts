import { BufferGeometry, Camera, type Intersection, Layers, Object3D, Ray, Raycaster, Vector2, Vector3 } from 'three';
import type { StaticGeometryGenerator } from 'three-mesh-bvh';
import { Context } from './engine_setup.js';
import type { Vec2, Vec3 } from './engine_types.js';
import type { IPhysicsEngine } from './engine_types.js';
export declare type RaycastTestObjectReturnType = void | boolean | "continue in children";
export declare type RaycastTestObjectCallback = (obj: Object3D) => RaycastTestObjectReturnType;
export declare interface IRaycastOptions {
    /** Optionally a custom raycaster can be provided. Other properties will then be set on this raycaster */
    raycaster?: Raycaster;
    /** Optional ray that can be used for raycasting
     *  @link https://threejs.org/docs/#api/en/math/Ray
     * */
    ray?: Ray;
    /** The camera to use for the raycaster */
    cam?: Camera | null;
    /** Point on screen in raycast space / normalized device coordinates (-1 to 1).
     * @link https://threejs.org/docs/#api/en/core/Raycaster.setFromCamera */
    screenPoint?: Vector2;
    /** Raycast results array. You can provide an array here to avoid creating a new one (note that if your array already contains items they will be removed) */
    results?: Array<Intersection>;
    /** Objects to raycast against. If no target array is provided the whole scene will be raycasted */
    targets?: Array<Object3D>;
    /**
     * If true, the raycaster will traverse the scene recursively.
     * @default true
     */
    recursive?: boolean;
    /**
     * If true, the raycaster will use a more precise method to test for intersections. This is slower but more accurate.
     * @default true
     */
    precise?: boolean;
    /** Set the raycaster near distance:
     * The near factor of the raycaster. This value indicates which objects can be discarded based on the distance. This value shouldn't be negative and should be smaller than the far property.
     * @link https://threejs.org/docs/#api/en/core/Raycaster.near
     */
    minDistance?: number;
    /** Set the raycaster far distance:
     * The far factor of the raycaster. This value indicates which objects can be discarded based on the distance. This value shouldn't be negative and should be larger than the near property.
     * @link https://threejs.org/docs/#api/en/core/Raycaster.far
     */
    maxDistance?: number;
    /** @link https://threejs.org/docs/#api/en/core/Raycaster.params */
    lineThreshold?: number;
    /** raw layer mask, use setLayer to set an individual layer active */
    layerMask?: Layers | number;
    ignore?: Object3D[];
    /** Optional calback function to be called per object before tested for intersections.
     * This can be used to filter objects.
     * Return `false` to ignore the object completely or `"continue in children"` to skip the object but continue to traverse its children (if you do raycast with `recursive` enabled)
     * */
    testObject?: RaycastTestObjectCallback;
    /**
     * Use MeshBVH for raycasting. This is faster than the default threejs raycaster but uses more memory.
     * @default undefined
     */
    useAcceleratedRaycast?: boolean;
}
export declare class RaycastOptions implements IRaycastOptions {
    static readonly AllLayers = 4294967295;
    ray?: Ray;
    cam?: Camera | null;
    screenPoint?: Vector2;
    raycaster?: Raycaster;
    results?: Array<Intersection>;
    targets?: Array<Object3D>;
    recursive?: boolean;
    minDistance?: number;
    maxDistance?: number;
    lineThreshold?: number;
    layerMask?: Layers | number;
    ignore?: Object3D[];
    testObject?: RaycastTestObjectCallback;
    useAcceleratedRaycast?: boolean | undefined;
    screenPointFromOffset(ox: number, oy: number): void;
    /** sets one layer for raycasting (e.g. layer 4, only objects on layer 4 will then be hit) */
    setLayer(layer: number): void;
    /** sets the layer.mask value directly, use setLayer if you want to set e.g. an individual layer only active. See https://threejs.org/docs/#api/en/core/Layers for more information about layers */
    setMask(mask: number): void;
}
export declare class SphereIntersection implements Intersection {
    distance: number;
    point: Vector3;
    object: Object3D;
    constructor(object: Object3D, distance: number, point: Vector3);
}
export declare class Physics {
    private static _raycasting;
    /**
     * Returns true if raycasting is currently happening
     */
    static get raycasting(): boolean;
    /**@deprecated use `this.context.physics.engine.raycast` {@link IPhysicsEngine.raycast} */
    raycastPhysicsFast(origin: Vec2 | Vec3, direction?: Vec3 | undefined, maxDistance?: number, solid?: boolean): {
        point: Vector3;
        collider: import("./engine_types.js").ICollider;
        normal?: Vector3 | undefined;
    } | null;
    /**@deprecated use `this.context.physics.engine.raycastAndGetNormal` {@link IPhysicsEngine.raycastAndGetNormal} */
    raycastPhysicsFastAndGetNormal(origin: Vec2 | Vec3, direction?: Vec3 | undefined, maxDistance?: number, solid?: boolean): {
        point: Vector3;
        collider: import("./engine_types.js").ICollider;
        normal?: Vector3 | undefined;
    } | null;
    /**@deprecated use this.context.physics.engine.sphereOverlap */
    sphereOverlapPhysics(point: Vector3, radius: number): import("./engine_types.js").SphereOverlapResult[] | null;
    private readonly context;
    engine?: IPhysicsEngine;
    constructor(context: Context);
    private readonly raycaster;
    private readonly defaultRaycastOptions;
    private readonly targetBuffer;
    private readonly defaultThresholds;
    private sphereResults;
    private sphereMask;
    private readonly sphere;
    /** Test overlapping of a sphere with the threejs geometry. This does not use colliders. This does not return an exact intersection point (intersections returned contain the object and the world position of the object that is being hit)
     * For a more accurate test use the physics engine's collider overlap test (see sphereOverlapPhysics)
     * @param spherePos the center of the sphere in world space
     * @param radius the radius of the sphere
     * @param traverseChildsAfterHit if false it will stop after the first hit. If true it will continue to traverse and add all hits to the result array
     * @param bvh use MeshBVH for raycasting. This is faster than the default threejs raycaster but uses more memory.
     * @param shouldRaycast optional callback to filter objects. Return `false` to ignore the object completely or `"continue in children"` to skip the object but continue to traverse its children (if you do raycast with `recursive` enabled)
     */
    sphereOverlap(spherePos: Vector3, radius: number, traverseChildsAfterHit?: boolean, bvh?: boolean, shouldRaycast?: RaycastTestObjectCallback | null): Array<Intersection>;
    raycastFromRay(ray: Ray, options?: IRaycastOptions | null): Array<Intersection>;
    /** raycast against rendered three objects. This might be very slow depending on your scene complexity.
     * We recommend setting objects to IgnoreRaycast layer (2) when you don't need them to be raycasted.
     * Raycasting SkinnedMeshes is specially expensive.
     * Use raycastPhysics for raycasting against physic colliders only. Depending on your scenario this might be faster.
     * @param options raycast options. If null, default options will be used.
     */
    raycast(options?: IRaycastOptions | null): Array<Intersection>;
    private intersect;
    private tempBoundingBox;
    private intersectSphere;
}
declare module 'three' {
    interface SkinnedMesh {
        staticGenerator?: StaticGeometryGenerator;
        staticGeometry?: BufferGeometry;
        staticGeometryLastUpdate?: number;
    }
    interface Mesh {
        acceleratedRaycast?: any;
    }
    interface SkinnedMesh {
        autoUpdateMeshBVH?: boolean;
        bvhNeedsUpdate?: boolean;
    }
}

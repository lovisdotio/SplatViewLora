import { Color, MirroredRepeatWrapping, PerspectiveCamera, WebGLRenderTarget } from "three";
import { Renderer } from "../engine-components/Renderer.js";
import { getComponentsInChildren } from "./engine_components.js";
import { ContextRegistry } from "./engine_context_registry.js";
import { RGBAColor } from "./js-extensions/index.js";
/**
 * Take a screenshot from the current scene.
 * **NOTE**: Use {@link screenshot2} for more options.
 *
 * @param context The context to take the screenshot from
 * @param width The width of the screenshot
 * @param height The height of the screenshot
 * @param mimeType The mime type of the image
 * @param camera The camera to use for the screenshot
 * @returns The data url of the screenshot. Returns null if the screenshot could not be taken.
 * @example
 * ```ts
 * const dataUrl = screenshot();
 * saveImage(dataUrl, "screenshot.png");
 * ```
 */
export function screenshot(context, width, height, mimeType = "image/webp", camera) {
    return screenshot2({ context, width, height, mimeType, camera });
}
export function screenshot2(opts) {
    if (!opts)
        opts = {};
    const { mimeType = "image/png", transparent = false } = opts;
    let { context, width, height, camera } = opts;
    if (!context) {
        context = ContextRegistry.Current;
        if (!context) {
            console.error("Can not save screenshot: No needle-engine context found or provided.");
            return null;
        }
    }
    if (!camera) {
        camera = context.mainCamera;
        if (!camera) {
            console.error("No camera found");
            return null;
        }
    }
    const prevWidth = context.renderer.domElement.width;
    const prevHeight = context.renderer.domElement.height;
    if (!width)
        width = prevWidth;
    if (!height)
        height = prevHeight;
    // apply page zoom
    const zoomLevel = window.devicePixelRatio || 1;
    width /= zoomLevel;
    height /= zoomLevel;
    // save XR state and reset it for screenshot
    const previousXRState = context.renderer.xr.enabled;
    context.renderer.xr.enabled = false;
    // reset style during screenshot
    context.renderer.domElement.style.width = width + "px";
    context.renderer.domElement.style.height = height + "px";
    const prevRenderTarget = context.renderer.getRenderTarget();
    const previousClearColor = context.renderer.getClearColor(new Color());
    const previousClearAlpha = context.renderer.getClearAlpha();
    const previousBackground = context.scene.background;
    const previousAspect = "aspect" in camera ? camera.aspect : null;
    try {
        const canvas = context.renderer.domElement;
        // Calling onBeforeRender to update objects with reflection probes. https://linear.app/needle/issue/NE-5112
        const callRenderEvents = opts.render_events !== false;
        const renderers = new Array();
        if (callRenderEvents) {
            getComponentsInChildren(context.scene, Renderer, renderers);
            renderers.forEach(r => r?.onBeforeRender());
        }
        if (transparent) {
            context.scene.background = null;
            context.renderer.setClearColor(0x000000, 0);
        }
        if (opts.background) {
            context.scene.background = null;
            context.renderer.setClearColor(opts.background);
            if (opts.background instanceof RGBAColor) {
                context.renderer.setClearAlpha(opts.background.a);
            }
        }
        if (transparent) {
            context.renderer.setClearAlpha(0);
        }
        // set the desired output size
        context.renderer.setSize(width, height, false);
        // If a camera component was provided
        if ("cam" in camera) {
            camera = camera.threeCamera;
        }
        // update the camera aspect and matrix
        if (camera instanceof PerspectiveCamera) {
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }
        const textureOutput = "type" in opts && opts.type === "texture";
        let targetTexture = null;
        if (textureOutput) {
            targetTexture = new WebGLRenderTarget(width, height, {
                wrapS: MirroredRepeatWrapping,
                wrapT: MirroredRepeatWrapping,
                format: 1023,
            });
            context.renderer.setRenderTarget(targetTexture);
        }
        // render now
        context.renderNow(camera || null);
        if (callRenderEvents)
            renderers.forEach(r => r.onAfterRender());
        if ("type" in opts) {
            if (opts.type === "texture") {
                if (!targetTexture) {
                    console.error("No target texture found");
                    return null;
                }
                if (opts.target) {
                    opts.target.image = targetTexture?.texture.image;
                    opts.target.needsUpdate = true;
                }
                targetTexture.texture.offset.set(0, -1);
                targetTexture.texture.needsUpdate = true;
                return targetTexture.texture;
            }
            else if (opts.type === "blob") {
                const promise = new Promise((resolve, _) => {
                    canvas.toBlob(blob => {
                        resolve(blob);
                    }, mimeType);
                });
                return promise;
            }
        }
        const dataUrl = canvas.toDataURL(mimeType);
        if ("download_filename" in opts && opts.download_filename) {
            saveImage(dataUrl, opts.download_filename);
        }
        return dataUrl;
    }
    finally {
        context.renderer.setRenderTarget(prevRenderTarget);
        context.scene.background = previousBackground;
        context.renderer.setSize(prevWidth, prevHeight, false);
        context.updateSize(true);
        context.renderer.setClearColor(previousClearColor, previousClearAlpha);
        // Make sure to reset the aspect ratio. This is crucial if the main camera is not the currently active rendering camera
        // For example if we did a screenshot from a different camera that has a different aspect ratio / fov
        if (previousAspect != null && camera instanceof PerspectiveCamera) {
            camera.aspect = previousAspect;
            camera.updateProjectionMatrix();
        }
        context.renderer.xr.enabled = previousXRState;
    }
    return null;
}
let saveImageElement = null;
/** Download a image (must be a data url).
 * @param dataUrl The data url of the image
 * @param filename The filename of the image
 * @example
 * ```ts
 * const dataUrl = screenshot();
 * saveImage(dataUrl, "screenshot.png");
 * ```
 */
export function saveImage(dataUrl, filename) {
    if (!dataUrl) {
        return;
    }
    if (!dataUrl.startsWith("data:image")) {
        console.error("Can not save image: Data url is not an image", dataUrl);
        return;
    }
    if (!saveImageElement) {
        saveImageElement = document.createElement("a");
    }
    saveImageElement.href = dataUrl;
    saveImageElement.download = filename;
    saveImageElement.click();
}
//# sourceMappingURL=engine_utils_screenshot.js.map
import { BufferGeometry, Matrix4, Mesh, Object3D, Quaternion, SpriteMaterial, Vector3 } from "three";
import type { Behavior, Particle } from "three.quarks";
import { ParticleSystem as _ParticleSystem } from "three.quarks";
import { Context } from "../../engine/engine_setup.js";
import { Behaviour, GameObject } from "../Component.js";
import { ColorBySpeedModule, ColorOverLifetimeModule, EmissionModule, InheritVelocityModule, type IParticleSystem, LimitVelocityOverLifetimeModule, MainModule, NoiseModule, ParticleSystemRenderMode, RotationBySpeedModule, RotationOverLifetimeModule, ShapeModule, SizeBySpeedModule, SizeOverLifetimeModule, TextureSheetAnimationModule, TrailModule, VelocityOverLifetimeModule } from "./ParticleSystemModules.js";
export type { Particle as QParticle, Behavior as QParticleBehaviour, TrailParticle as QTrailParticle } from "three.quarks";
export declare enum SubEmitterType {
    Birth = 0,
    Collision = 1,
    Death = 2,
    Trigger = 3,
    Manual = 4
}
/** @internal */
export declare class ParticleSystemRenderer extends Behaviour {
    renderMode?: ParticleSystemRenderMode;
    particleMaterial?: SpriteMaterial;
    trailMaterial?: SpriteMaterial;
    particleMesh?: Mesh | string;
    maxParticleSize: number;
    minParticleSize: number;
    velocityScale?: number;
    cameraVelocityScale?: number;
    lengthScale?: number;
    start(): void;
    get transparent(): boolean;
    getMaterial(trailEnabled?: boolean): SpriteMaterial | undefined;
    getMesh(_renderMode?: ParticleSystemRenderMode): Mesh<BufferGeometry<import("three").NormalBufferAttributes>, SpriteMaterial, import("three").Object3DEventMap>;
}
export declare abstract class ParticleSystemBaseBehaviour implements Behavior {
    system: ParticleSystem;
    get context(): Context;
    constructor(ps?: ParticleSystem);
    type: string;
    initialize(_particle: Particle): void;
    update(_particle: Particle, _delta: number): void;
    frameUpdate(_delta: number): void;
    toJSON(): void;
    clone(): Behavior;
    reset(): void;
}
export declare const $particleLife: unique symbol;
/**
 * The ParticleSystem component efficiently handles the motion and rendering of many individual particles.
 *
 * You can add custom behaviours to the particle system to fully customize the behaviour of the particles. See {@link ParticleSystemBaseBehaviour} and {@link ParticleSystem.addBehaviour} for more information.
 *
 * Needle Engine uses [three.quarks](https://github.com/Alchemist0823/three.quarks) under the hood to handle particles.
 *
 * @category Rendering
 */
export declare class ParticleSystem extends Behaviour implements IParticleSystem {
    play(includeChildren?: boolean): void;
    pause(includeChildren?: boolean): void;
    /** clear=true removes all emitted particles */
    stop(includeChildren?: boolean, clear?: boolean): void;
    /** remove emitted particles and reset time */
    reset(): void;
    private _state?;
    emit(count: number): void;
    get playOnAwake(): boolean;
    set playOnAwake(val: boolean);
    readonly colorOverLifetime: ColorOverLifetimeModule;
    readonly main: MainModule;
    readonly emission: EmissionModule;
    readonly sizeOverLifetime: SizeOverLifetimeModule;
    readonly shape: ShapeModule;
    readonly noise: NoiseModule;
    readonly trails: TrailModule;
    readonly velocityOverLifetime: VelocityOverLifetimeModule;
    readonly limitVelocityOverLifetime: LimitVelocityOverLifetimeModule;
    inheritVelocity: InheritVelocityModule;
    readonly colorBySpeed: ColorBySpeedModule;
    readonly textureSheetAnimation: TextureSheetAnimationModule;
    readonly rotationOverLifetime: RotationOverLifetimeModule;
    readonly rotationBySpeed: RotationBySpeedModule;
    readonly sizeBySpeed: SizeBySpeedModule;
    get renderer(): ParticleSystemRenderer;
    get isPlaying(): boolean;
    get currentParticles(): number;
    get maxParticles(): number;
    get time(): number;
    get duration(): number;
    get deltaTime(): number;
    get scale(): number;
    get cameraScale(): number;
    private _cameraScale;
    get container(): Object3D;
    get worldspace(): boolean;
    get localspace(): boolean;
    private __worldQuaternion;
    get worldQuaternion(): Quaternion;
    private _worldQuaternionInverted;
    get worldQuaternionInverted(): Quaternion;
    private _worldScale;
    get worldScale(): Vector3;
    private _worldPositionFrame;
    private _worldPos;
    get worldPos(): Vector3;
    get matrixWorld(): Matrix4;
    get isSubsystem(): boolean;
    /** Add a custom quarks behaviour to the particle system.
     * You can add a quarks.Behaviour type or derive from {@link ParticleSystemBaseBehaviour}
     * @link https://github.com/Alchemist0823/three.quarks
     * @example
     * ```typescript
     * class MyBehaviour extends ParticleSystemBaseBehaviour {
     *    initialize(particle: Particle) {
     *       // initialize the particle
     *   }
     *    update(particle: Particle, delta: number) {
     *        // do something with the particle
     *   }
     * }
     *
     * const system = gameObject.getComponent(ParticleSystem);
     * system.addBehaviour(new MyBehaviour());
     * ```
    */
    addBehaviour(particleSystemBehaviour: Behavior | ParticleSystemBaseBehaviour): boolean;
    /** Remove a custom quarks behaviour from the particle system. **/
    removeBehaviour(particleSystemBehaviour: Behavior | ParticleSystemBaseBehaviour): boolean;
    /** Removes all behaviours from the particle system
     * **Note:** this will also remove the default behaviours like SizeBehaviour, ColorBehaviour etc.
     */
    removeAllBehaviours(): boolean;
    /** Get the underlying three.quarks particle system behaviours. This can be used to fully customize the behaviour of the particles. */
    get behaviours(): Behavior[] | null;
    /** Get access to the underlying quarks particle system if you need more control
     * @link https://github.com/Alchemist0823/three.quarks
     */
    get particleSystem(): _ParticleSystem | null;
    private _renderer;
    private _batchSystem?;
    private _particleSystem?;
    private _interface;
    private _container;
    private _time;
    private _isPlaying;
    private _isUsedAsSubsystem;
    private _didPreWarm;
    /** called from deserialization */
    private set bursts(value);
    private _bursts?;
    /** called from deserialization */
    private set subEmitterSystems(value);
    private _subEmitterSystems?;
    /** @internal */
    onAfterDeserialize(_: any): void;
    /** @internal */
    awake(): void;
    /** @internal */
    start(): void;
    /** @internal */
    onDestroy(): void;
    /** @internal */
    onEnable(): void;
    onDisable(): void;
    /** @internal */
    onBeforeRender(): void;
    private preWarm;
    private _lastBatchesCount;
    private onSimulate;
    private updateLayers;
    private lastMaterialVersion;
    private onUpdate;
    private addSubParticleSystems;
}
/** @internal */
export declare class SubEmitterSystem {
    particleSystem?: ParticleSystem;
    emitProbability: number;
    properties?: number;
    type?: SubEmitterType;
    _deserialize(_context: Context, gameObject: GameObject): void;
}

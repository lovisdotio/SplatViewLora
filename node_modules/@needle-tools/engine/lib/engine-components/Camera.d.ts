import { Euler, Frustum, Matrix4, OrthographicCamera, PerspectiveCamera, Ray } from "three";
import { Context } from "../engine/engine_setup.js";
import { RenderTexture } from "../engine/engine_texture.js";
import type { ICamera } from "../engine/engine_types.js";
import { RGBAColor } from "../engine/js-extensions/index.js";
import { Behaviour } from "./Component.js";
/**  The ClearFlags enum is used to determine how the camera clears the background */
export declare enum ClearFlags {
    None = 0,
    /** Clear the background with a skybox */
    Skybox = 1,
    /** Clear the background with a solid color. The alpha channel of the color determines the transparency */
    SolidColor = 2,
    /** Clear the background with a transparent color */
    Uninitialized = 4
}
/**
 * @category Camera Controls
 */
export declare class Camera extends Behaviour implements ICamera {
    get isCamera(): boolean;
    /** The camera's aspect ratio (width divided by height) if it is a perspective camera */
    get aspect(): number;
    set aspect(value: number);
    /** The camera's field of view in degrees if it is a perspective camera */
    get fieldOfView(): number | undefined;
    set fieldOfView(val: number | undefined);
    /** The camera's near clipping plane */
    get nearClipPlane(): number;
    set nearClipPlane(val: number);
    private _nearClipPlane;
    applyClippingPlane(): void;
    /** The camera's far clipping plane */
    get farClipPlane(): number;
    set farClipPlane(val: number);
    private _farClipPlane;
    /** The camera's clear flags - determines if the background is a skybox or a solid color or transparent */
    get clearFlags(): ClearFlags;
    set clearFlags(val: ClearFlags);
    orthographic: boolean;
    orthographicSize: number;
    ARBackgroundAlpha: number;
    /**
     * The [`mask`](https://threejs.org/docs/#api/en/core/Layers.mask) value of the three camera object layers
     * If you want to just see objects on one layer (e.g. layer 2) then you can use `cullingLayer = 2` on this camera component instead
    */
    set cullingMask(val: number);
    get cullingMask(): number;
    private _cullingMask;
    /** Set only a specific layer active to be rendered by the camera.
     * This is equivalent to calling `layers.set(val)`
     **/
    set cullingLayer(val: number);
    /** The blurriness of the background texture (when using a skybox) */
    set backgroundBlurriness(val: number | undefined);
    get backgroundBlurriness(): number | undefined;
    private _backgroundBlurriness?;
    /** The intensity of the background texture (when using a skybox) */
    set backgroundIntensity(val: number | undefined);
    get backgroundIntensity(): number | undefined;
    private _backgroundIntensity?;
    /** the rotation of the background texture (when using a skybox) */
    set backgroundRotation(val: Euler | undefined);
    get backgroundRotation(): Euler | undefined;
    private _backgroundRotation?;
    /** The intensity of the environment map */
    set environmentIntensity(val: number | undefined);
    get environmentIntensity(): number | undefined;
    private _environmentIntensity?;
    /** The background color of the camera when {@link ClearFlags} are set to `SolidColor` */
    get backgroundColor(): RGBAColor | null;
    set backgroundColor(val: RGBAColor | null);
    /** The texture that the camera should render to
     * It can be used to render to a {@link Texture} instead of the screen.
    */
    set targetTexture(rt: RenderTexture | null);
    get targetTexture(): RenderTexture | null;
    private _targetTexture;
    private _backgroundColor?;
    private _fov?;
    private _cam;
    private _clearFlags;
    private _skybox?;
    /**
     * Get the three.js camera object. This will create a camera if it does not exist yet.
     * @returns {PerspectiveCamera | OrthographicCamera} the three camera
     * @deprecated use {@link threeCamera} instead
     */
    get cam(): PerspectiveCamera | OrthographicCamera;
    /**
     * Get the three.js camera object. This will create a camera if it does not exist yet.
     * @returns {PerspectiveCamera | OrthographicCamera} the three camera
     */
    get threeCamera(): PerspectiveCamera | OrthographicCamera;
    private static _origin;
    private static _direction;
    screenPointToRay(x: number, y: number, ray?: Ray): Ray;
    private _frustum?;
    /**
     * Get a frustum - it will be created the first time this method is called and updated every frame in onBeforeRender when it exists.
     * You can also manually update it using the updateFrustum method.
     */
    getFrustum(): Frustum;
    /** Force frustum update - note that this also happens automatically every frame in onBeforeRender */
    updateFrustum(): void;
    /**
     * @returns {Matrix4} this camera's projection screen matrix.
     */
    getProjectionScreenMatrix(target: Matrix4, forceUpdate?: boolean): Matrix4;
    private readonly _projScreenMatrix;
    /** @internal */
    awake(): void;
    /** @internal */
    onEnable(): void;
    /** @internal */
    onDisable(): void;
    /** @internal */
    onBeforeRender(): void;
    /**
     * Creates a {@link PerspectiveCamera} if it does not exist yet and set the camera's properties. This is internally also called when accessing the {@link cam} property.
     **/
    buildCamera(): void;
    applyClearFlagsIfIsActiveCamera(opts?: {
        applySkybox: boolean;
    }): void;
    /** Apply this camera's clear flags and related settings to the renderer */
    applyClearFlags(opts?: {
        applySkybox: boolean;
    }): void;
    /**
     * Apply the skybox to the scene
     */
    applySceneSkybox(): void;
    /** Used to determine if the background should be transparent when in pass through AR
     * @returns true when in XR on a pass through device where the background shouldbe invisible
     **/
    static backgroundShouldBeTransparent(context: Context): boolean;
}

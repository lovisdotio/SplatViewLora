var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { BlendFunction, Effect } from "postprocessing";
import { Uniform } from "three";
import { serializable } from "../../../engine/engine_serialization.js";
import { PostProcessingEffect } from "../PostProcessingEffect.js";
/**
 * @category Effects
 */
export class SharpeningEffect extends PostProcessingEffect {
    get typeName() {
        return "Sharpening";
    }
    _effect;
    onCreateEffect() {
        return this.effect;
    }
    get effect() {
        this._effect ??= new _SharpeningEffect();
        return this._effect;
    }
    set amount(value) {
        this.effect.uniforms.get("amount").value = value;
    }
    get amount() {
        return this.effect.uniforms.get("amount").value;
    }
    set radius(value) {
        this.effect.uniforms.get("radius").value = value;
    }
    get radius() {
        return this.effect.uniforms.get("radius").value;
    }
}
__decorate([
    serializable()
], SharpeningEffect.prototype, "amount", null);
__decorate([
    serializable()
], SharpeningEffect.prototype, "radius", null);
const vert = `
  void mainSupport() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;
const frag = `
uniform sampler2D tDiffuse;
uniform float amount;
uniform float radius;

void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
    float tx = 1.0 / resolution.x;
    float ty = 1.0 / resolution.y;
    vec2 texelSize = vec2(tx, ty);

    vec4 blurred = vec4(0.0);
    float total = 0.0;

    for (float x = -radius; x <= radius; x++) {
        for (float y = -radius; y <= radius; y++) {
            vec2 offset = vec2(x, y) * texelSize;
            vec4 diffuse = texture2D(tDiffuse, uv + offset);
            float weight = exp(-length(offset) * amount);
            blurred += diffuse * weight;
            total += weight;
        }
    }

    if (total > 0.0) {
        blurred /= total;
    }

    // Calculate the sharpened color using inputColor
    vec4 sharp = inputColor + clamp(inputColor - blurred, 0.0, 1.0) * amount;
    // Keep original alpha
    sharp.a = inputColor.a;

    // Ensure the sharp color does not go below 0 or above 1
    // This means: sharpening must happen AFTER tonemapping.
    sharp = clamp(sharp, 0.0, 1.0);

    outputColor = sharp;
}

`;
class _SharpeningEffect extends Effect {
    constructor() {
        super("Sharpening", frag, {
            vertexShader: vert,
            blendFunction: BlendFunction.NORMAL,
            uniforms: new Map([
                ["amount", new Uniform(1)],
                ["radius", new Uniform(1)],
                // ["threshold", new Uniform(0)],
            ]),
        });
    }
}
export { _SharpeningEffect };
//# sourceMappingURL=Sharpening.js.map
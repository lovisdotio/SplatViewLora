import { Color, Vector3 } from "three";
import type { ILight } from "../engine/engine_types.js";
import { type NeedleXREventArgs } from "../engine/xr/api.js";
import { Behaviour } from "./Component.js";
export declare enum LightType {
    Spot = 0,
    Directional = 1,
    Point = 2,
    Area = 3,
    Rectangle = 3,
    Disc = 4
}
export declare enum LightmapBakeType {
    Realtime = 4,
    Baked = 2,
    Mixed = 1
}
declare enum LightShadows {
    None = 0,
    Hard = 1,
    Soft = 2
}
/** The Light component can be used to create a light source in the scene.
 * It can be used to create a directional light, a spot light or a point light.
 * The light can be set to cast shadows and the shadow type can be set to hard or soft shadows.
 * The light can be set to be baked or realtime.
 * The light can be set to be a main light which will be used for the main directional light in the scene.
 * @category Rendering
 */
export declare class Light extends Behaviour implements ILight {
    private type;
    range: number;
    spotAngle: number;
    innerSpotAngle: number;
    set color(val: Color);
    get color(): Color;
    _color: Color;
    set shadowNearPlane(val: number);
    get shadowNearPlane(): number;
    private _shadowNearPlane;
    set shadowBias(val: number);
    get shadowBias(): number;
    private _shadowBias;
    set shadowNormalBias(val: number);
    get shadowNormalBias(): number;
    private _shadowNormalBias;
    /** when enabled this will remove the multiplication when setting the shadow bias settings initially */
    private _overrideShadowBiasSettings;
    set shadows(val: LightShadows);
    get shadows(): LightShadows;
    private _shadows;
    private lightmapBakeType;
    set intensity(val: number);
    get intensity(): number;
    private _intensity;
    get shadowDistance(): number;
    set shadowDistance(val: number);
    private _shadowDistance?;
    private shadowWidth?;
    private shadowHeight?;
    get shadowResolution(): number;
    set shadowResolution(val: number);
    private _shadowResolution?;
    get isBaked(): boolean;
    private get selfIsLight();
    private light;
    getWorldPosition(vec: Vector3): Vector3;
    awake(): void;
    onEnable(): void;
    onDisable(): void;
    private _webXRStartedListener?;
    private _webXREndedListener?;
    private _webARRoot?;
    onEnterXR(_args: NeedleXREventArgs): void;
    onLeaveXR(_args: NeedleXREventArgs): void;
    createLight(): void;
    updateMainLightRoutine(): Generator<undefined, void, unknown>;
    static allowChangingRendererShadowMapType: boolean;
    private updateShadowSoftHard;
    private setDirectionalLight;
}
export {};

import { BufferGeometry, Material, Mesh, MeshBasicMaterial, Texture } from "three";
import { RGBAColor } from "../engine/js-extensions/index.js";
import { Behaviour } from "./Component.js";
export declare enum SpriteDrawMode {
    Simple = 0,
    Sliced = 1,
    Tiled = 2
}
declare class Vec2 {
    x: number;
    y: number;
}
/**
 * A sprite is a mesh that represents a 2D image
 * @category Rendering
 */
export declare class Sprite {
    constructor(texture?: Texture);
    guid?: string;
    texture?: Texture;
    triangles: Array<number>;
    uv: Array<Vec2>;
    vertices: Array<Vec2>;
    /** @internal */
    __cached_geometry?: BufferGeometry;
    /**
     * The mesh that represents the sprite
     */
    get mesh(): Mesh;
    private _mesh;
    /**
     * The material used to render the sprite
     */
    get material(): MeshBasicMaterial;
    private _material;
    /**
     * The geometry of the sprite that can be used to create a mesh
     */
    getGeometry(): BufferGeometry<import("three").NormalBufferAttributes>;
}
export declare class SpriteSheet {
    sprites: Sprite[];
}
export declare class SpriteData {
    static create(): SpriteData;
    constructor();
    /**
     * Set the sprite to be rendered in the currently assigned sprite sheet at the currently active index {@link index}
     */
    set sprite(sprite: Sprite | undefined);
    /** The currently active sprite */
    get sprite(): Sprite | undefined;
    /**
     * The spritesheet holds all sprites that can be rendered by the sprite renderer
     */
    spriteSheet?: SpriteSheet;
    /**
     * The index of the sprite to be rendered in the currently assigned sprite sheet
     */
    index: number;
    update(material: Material | undefined): void;
}
/**
 * The sprite renderer renders a sprite on a GameObject using an assigned spritesheet ({@link SpriteData}).
 */
export declare class SpriteRenderer extends Behaviour {
    /** @internal The draw mode of the sprite renderer */
    drawMode: SpriteDrawMode;
    /** @internal Used when drawMode is set to Tiled */
    size: Vec2;
    color?: RGBAColor;
    /**
     * The material that is used to render the sprite
     */
    sharedMaterial?: Material;
    transparent: boolean;
    cutoutThreshold: number;
    castShadows: boolean;
    renderOrder: number;
    toneMapped: boolean;
    /**
     * Assign a new texture to the currently active sprite
     */
    set texture(value: Texture | undefined);
    /**
     * Add a new sprite to the currently assigned sprite sheet. The sprite will be added to the end of the sprite sheet.
     * Note that the sprite will not be rendered by default - set the `spriteIndex` to the index of the sprite to be rendered.
     * @param sprite The sprite to be added
     * @returns The index of the sprite in the sprite sheet
     * @example
     * ```typescript
     * const spriteRenderer = gameObject.addComponent(SpriteRenderer);
     * const index = spriteRenderer.addSprite(mySprite);
     * if(index >= 0)
     *   spriteRenderer.spriteIndex = index;
     * ```
     */
    addSprite(sprite: Sprite, setActive?: boolean): number;
    /**
     * Get the currently active sprite
     */
    get sprite(): SpriteData | undefined;
    /**
     * Set the sprite to be rendered in the currently assigned sprite sheet at the currently active index {@link spriteIndex}
     */
    set sprite(value: Sprite | SpriteData | undefined | number);
    /**
     * Set the index of the sprite to be rendered in the currently assigned sprite sheet
     */
    set spriteIndex(value: number);
    get spriteIndex(): number;
    /**
     * Get the number of sprites in the currently assigned sprite sheet
     */
    get spriteFrames(): number;
    private _spriteSheet?;
    private _currentSprite?;
    /** @internal */
    awake(): void;
    /** @internal */
    start(): void;
    /**
     * Update the sprite. Modified properties will be applied to the sprite mesh. This method is called automatically when the sprite is changed.
     * @param force If true, the sprite will be forced to update.
     * @returns True if the sprite was updated successfully
     */
    updateSprite(force?: boolean): boolean;
}
export {};

import { getParam } from "../../../../../engine/engine_utils.js";
import { GameObject } from "../../../../Component.js";
import { AudioExtension } from "./AudioExtension.js";
import { ActionModel, GroupActionModel, TriggerModel } from "./BehavioursBuilder.js";
const debug = getParam("debugusdzbehaviours");
/** internal USDZ behaviours extension */
export class BehaviorExtension {
    get extensionName() {
        return "Behaviour";
    }
    behaviours = [];
    addBehavior(beh) {
        this.behaviours.push(beh);
    }
    /** Register audio clip for USDZ export. The clip will be embedded in the resulting file. */
    addAudioClip(clipUrl) {
        if (!clipUrl)
            return "";
        if (typeof clipUrl !== "string")
            return "";
        const clipName = AudioExtension.getName(clipUrl);
        const filesKey = "audio/" + clipName;
        this.audioClips.push({ clipUrl, filesKey });
        return filesKey;
    }
    behaviourComponents = [];
    behaviourComponentsCopy = [];
    audioClips = [];
    audioClipsCopy = [];
    targetUuids = new Set();
    getAllTargetUuids() {
        return this.targetUuids;
    }
    onBeforeBuildDocument(context) {
        if (!context.root)
            return Promise.resolve();
        const beforeCreateDocumentPromises = [];
        context.root.traverse(e => {
            GameObject.foreachComponent(e, (comp) => {
                const c = comp;
                // Test if the components has any of the behaviour type methods
                if (typeof c.createBehaviours === "function" ||
                    typeof c.beforeCreateDocument === "function" ||
                    typeof c.afterCreateDocument === "function" ||
                    typeof c.afterSerialize === "function") {
                    this.behaviourComponents.push(c);
                    // run beforeCreateDocument. We run them in parallel if any of them is async because the order in which this is invoked on the components is not guaranteed anyways 
                    // (or at least no behaviour component should rely on another to have finished this method)
                    const res = c.beforeCreateDocument?.call(c, this, context);
                    if (res instanceof Promise) {
                        beforeCreateDocumentPromises.push(res);
                    }
                }
            }, false);
        });
        if (debug)
            console.log("onBeforeBuildDocument: all components", this.behaviourComponents);
        return Promise.all(beforeCreateDocumentPromises);
    }
    onExportObject(_object, model, context) {
        for (const beh of this.behaviourComponents) {
            if (debug)
                console.log("onExportObject: createBehaviours", beh);
            beh.createBehaviours?.call(beh, this, model, context);
        }
    }
    onAfterBuildDocument(context) {
        for (const beh of this.behaviourComponents) {
            if (typeof beh.afterCreateDocument === "function")
                beh.afterCreateDocument(this, context);
        }
        this.behaviourComponentsCopy = this.behaviourComponents.slice();
        this.behaviourComponents.length = 0;
        this.audioClipsCopy = this.audioClips.slice();
        this.audioClips.length = 0;
        // We want to know all trigger sources and action targets.
        // These can be nested in Group Actions.
        const triggerSources = new Set();
        const actionTargets = new Set();
        const targetUuids = new Set();
        function collect(actionModel) {
            if (actionModel instanceof GroupActionModel) {
                for (const action of actionModel.actions) {
                    collect(action);
                }
            }
            else if (actionModel instanceof ActionModel) {
                const affected = actionModel.affectedObjects;
                if (affected) {
                    if (typeof affected === "object")
                        actionTargets.add(affected);
                    else if (typeof affected === "string")
                        actionTargets.add({ uuid: affected });
                }
                const xform = actionModel.xFormTarget;
                if (xform) {
                    if (typeof xform === "object")
                        actionTargets.add(xform);
                    else if (typeof xform === "string")
                        actionTargets.add({ uuid: xform });
                }
            }
        }
        // collect all targets of all triggers and actions
        for (const beh of this.behaviours) {
            if (beh.trigger instanceof TriggerModel && typeof beh.trigger.targetId === "object")
                triggerSources.add(beh.trigger.targetId);
            collect(beh.action);
        }
        for (const source of new Set([...triggerSources, ...actionTargets])) {
            // shouldn't happen but strictly speaking a trigger source could be set to an array
            if (Array.isArray(source)) {
                for (const s of source)
                    targetUuids.add(s.uuid);
            }
            else
                targetUuids.add(source.uuid);
        }
        if (debug)
            console.log("All Behavior trigger sources and action targets", triggerSources, actionTargets, targetUuids);
        this.targetUuids = new Set(targetUuids);
    }
    onAfterHierarchy(context, writer) {
        if (this.behaviours?.length) {
            writer.beginBlock('def Scope "Behaviors"');
            for (const beh of this.behaviours)
                beh.writeTo(this, context.document, writer);
            writer.closeBlock();
        }
    }
    async onAfterSerialize(context) {
        if (debug)
            console.log("onAfterSerialize behaviours", this.behaviourComponentsCopy);
        for (const beh of this.behaviourComponentsCopy) {
            if (typeof beh.afterSerialize === "function") {
                const isAsync = beh.afterSerialize.constructor.name === "AsyncFunction";
                if (isAsync) {
                    await beh.afterSerialize(this, context);
                }
                else {
                    beh.afterSerialize(this, context);
                }
            }
        }
        for (const { clipUrl, filesKey } of this.audioClipsCopy) {
            // if the clip was already added, don't add it again
            if (context.files[filesKey])
                return;
            const audio = await fetch(clipUrl);
            const audioBlob = await audio.blob();
            const arrayBuffer = await audioBlob.arrayBuffer();
            const audioData = new Uint8Array(arrayBuffer);
            context.files[filesKey] = audioData;
        }
        // cleanup
        this.behaviourComponentsCopy.length = 0;
        this.audioClipsCopy.length = 0;
    }
}
// const playAnimationOnTap = new BehaviorModel("b_" + model.name + "_playanim", TriggerBuilder.tapTrigger(model),
//     ActionBuilder.parallel(
//         ActionBuilder.lookAtCameraAction(model),
//         ActionBuilder.sequence(
//             //ActionBuilder.startAnimationAction(model, 0, 0, 1, false, true),
//             ActionBuilder.emphasize(model, 1, MotionType.Float),
//             ActionBuilder.waitAction(1),
//             ActionBuilder.emphasize(model, 1, MotionType.Blink),
//             ActionBuilder.waitAction(1),
//             ActionBuilder.emphasize(model, 1, MotionType.Jiggle),
//             ActionBuilder.waitAction(1),
//             ActionBuilder.emphasize(model, 1, MotionType.Pulse),
//             ActionBuilder.waitAction(1),
//             ActionBuilder.emphasize(model, 1, MotionType.Spin),
//             ActionBuilder.waitAction(1),
//             ActionBuilder.emphasize(model, 1, MotionType.Bounce),
//             ActionBuilder.waitAction(1),
//             ActionBuilder.emphasize(model, 1, MotionType.Flip),
//             ActionBuilder.waitAction(1),
//         ).makeLooping()
//     ).makeLooping()
// );
// this.behaviours.push(playAnimationOnTap);
// return;
// const identityMatrix = new Matrix4().identity();
// const emptyParent = new USDZObject(model.name + "_empty", model.matrix);
// const parent = model.parent;
// parent.add(emptyParent);
// model.matrix = identityMatrix;
// emptyParent.add(model);
// const geometry = new SphereGeometry(.6, 32, 16);
// const modelVariant = new USDZObject(model.name + "_variant", identityMatrix, geometry, new MeshStandardMaterial({ color: 0xff0000 }));
// emptyParent.add(modelVariant);
// const matrix2 = new Matrix4();
// matrix2.makeTranslation(.5, 0, 0);
// const modelVariant2 = new USDZObject(model.name + "_variant2", matrix2, geometry, new MeshStandardMaterial({ color: 0xffff00 }));
// emptyParent.add(modelVariant2);
// const hideVariantOnStart = new BehaviorModel("b_" + model.name + "_start", TriggerBuilder.sceneStartTrigger(), ActionBuilder.fadeAction(modelVariant, 0, false));
// this.behaviours.push(hideVariantOnStart);
// const showVariant = new BehaviorModel("b_" + model.name + "_show_variant", [TriggerBuilder.tapTrigger(model)], new GroupActionModel("group", [
//     ActionBuilder.fadeAction(model, 0, false),
//     ActionBuilder.fadeAction(modelVariant, 0, true),
// ]));
// this.behaviours.push(showVariant);
// const showOriginal = new BehaviorModel("b_" + model.name + "_show_original", [
//     TriggerBuilder.tapTrigger(modelVariant),
//     TriggerBuilder.tapTrigger(modelVariant2)
// ],
//     new GroupActionModel("group", [
//         ActionBuilder.fadeAction([modelVariant, modelVariant2], 0, false),
//         //ActionBuilder.waitAction(1),
//         ActionBuilder.fadeAction(model, 0, true),
//         //ActionBuilder.waitAction(.2),
//         ActionBuilder.startAnimationAction(model, 0, 1000, 1, false, true),
//         //ActionBuilder.lookAtCameraAction(model, 2, Vec3.forward, Vec3.up),
//         //ActionBuilder.waitAction(1),
//         //ActionBuilder.fadeAction(modelVariant2, 0, true),
//     ]).makeSequence());
// this.behaviours.push(showOriginal);
//# sourceMappingURL=Behaviour.js.map
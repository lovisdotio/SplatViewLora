import { ChildProcess, exec, execSync, spawn } from 'child_process';
import { getOutputDirectory, loadConfig, tryLoadProjectConfig } from './config.js';
import { existsSync, readFileSync, readdirSync, writeFileSync } from 'fs';

// see https://linear.app/needle/issue/NE-3798

export let buildPipelineTask;

/**
 * Runs the needle build pipeline as part of the vite build process
 * @param {import('../types').userSettings} userSettings
 * @returns {import('vite').Plugin}
 */
export const needleBuildPipeline = async (command, config, userSettings) => {

    // we only want to run compression here if this is a distribution build
    // this is handled however in the `apply` hook
    if (userSettings.noBuildPipeline) return;

    const packageJsonPath = process.cwd() + "/package.json";
    await fixPackageJson(packageJsonPath);


    let shouldRun = false;
    const productionArgument = process.argv.indexOf("--production");
    if (productionArgument >= 0) {
        shouldRun = true;
    }
    else {
        const meta = await loadConfig();
        if (meta && meta.developmentBuild === false) {
            shouldRun = true;
        }
    }

    if (!shouldRun) {
        log("Skipping build pipeline because this is a development build.\n- Invoke with `--production` to run the build pipeline.\n- For example \"vite build -- --production\".");
        await new Promise((resolve, _) => setTimeout(resolve, 1000));
        return;
    }

    /** @type {Promise<any>|null} */
    let task = null;
    let taskFinished = false;
    let taskSucceeded = false;
    return {
        name: 'needle:buildpipeline',
        enforce: "post",
        apply: 'build',
        buildEnd() {
            // start the compression process once vite is done copying the files
            task = invokeBuildPipeline(userSettings).then((res) => {
                taskFinished = true;
                taskSucceeded = res;
            });
            buildPipelineTask = task;
        },
        closeBundle() {
            log("Waiting for postprocessing to finish...");
            // this is the last hook that is called, so we can wait for the task to finish here
            if (taskFinished) return;
            // delay the final log slightly to give other plugins a chance to log their stuff
            wait(100).then(() => {
                if (!taskFinished) log("Waiting for postprocessing to finish...")
            });
            return task.then(_ => {
                log("finished", taskSucceeded ? "successfully" : "with errors");
            });
        },
    }
}

/**
 * Previously we did always install the build pipeline and run an extra command to invoke the build pipeline.  
 * This is now done automatically by the needle build pipeline plugin - so we update all legacy projects to use the new method.
 */
async function fixPackageJson(packageJsonPath) {
    if (!existsSync(packageJsonPath)) {
        return;
    }
    const text = readFileSync(packageJsonPath, "utf8");
    const oldScript = `"build:production": "npm run build:dev && npm run gltf:transform"`;
    const newScript = `"build:production": "vite build -- --production"`;
    const fixed = text.replace(oldScript, newScript);
    if (fixed === text) return;
    log("Automatically updated package.json production build script");
    log("- FROM " + oldScript);
    log("- TO " + newScript);
    writeFileSync(packageJsonPath, fixed);
}

function log(...args) {
    console.log("[needle-buildpipeline]", ...args);
}
function warn(...args) {
    console.warn("WARN: [needle-buildpipeline]", ...args);
}

/**
 * @param {import('../types').userSettings} opts 
 * @returns {Promise<boolean>}
 */
async function invokeBuildPipeline(opts) {
    const installPath = "node_modules/@needle-tools/gltf-build-pipeline";
    const fullInstallPath = process.cwd() + "/" + installPath;
    const existsLocally = existsSync(fullInstallPath);
    if (!existsLocally) {
        // await execSync("npx --yes @needle-tools/n")
        // throw new Error(`ERR: Build pipeline not found at \"${fullInstallPath}\". \nTo disable this plugin you can pass \"noBuildPipeline: true\" to the needle config in vite.config.js`);
        warn("@needle-tools/gltf-build-pipeline not found in package - using latest version")
    }
    await wait(500);
    const outputDirectory = getOutputDirectory() + "/assets";
    // wait until the output directory exists - this depends on speed
    function waitForOutputDirectory(iteration) {
        if (!existsSync(outputDirectory)) {
            if (iteration > 10) {
                return Promise.resolve(false);
            }
            if (iteration <= 0) log("Waiting for output directory to be created...");
            return wait(1000).then(() => waitForOutputDirectory(iteration + 1));
        }
        return Promise.resolve(true);
    }
    if (!await waitForOutputDirectory(0)) {
        warn("Directory not found at " + outputDirectory);
        return;
    }
    const files = readdirSync(outputDirectory).filter(f => f.endsWith(".glb") || f.endsWith(".gltf"));
    log(files.length + " file(s) to process");

    /** @type {null | ChildProcess} */
    let sub = null;

    if (existsLocally) {
        const cmd = `needle-gltf transform "${outputDirectory}"`;
        log("Running command \"" + cmd + "\" at " + process.cwd() + "...");
        sub = exec(cmd, { cwd: installPath });
    }
    else {
        const version = opts.buildPipelineVersion || "latest";
        const cmd = `npx --yes @needle-tools/gltf-build-pipeline@${version} transform "${outputDirectory}"`;
        log("Running command \"" + cmd);
        sub = exec(cmd);
    }
    sub.stdout.on('data', data => {
        if (data.length <= 0) return;
        // ensure that it doesnt end with a newline
        if (data.endsWith("\n")) data = data.slice(0, -1);
        console.log(data);
    });
    sub.stderr.on('data', console.error);
    return new Promise((resolve, reject) => {
        sub.on('exit', (code) => {
            resolve(code === 0);
        });
    });
}

function wait(ms) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve();
        }, ms);
    });
}
import { Camera, CanvasTexture, Color, ColorRepresentation, MirroredRepeatWrapping, PerspectiveCamera, RepeatWrapping, Texture, Vector2, WebGLRenderTarget } from "three";

import { Renderer } from "../engine-components/Renderer.js";
import { getComponentsInChildren } from "./engine_components.js";
import { ContextRegistry } from "./engine_context_registry.js";
import { Context } from "./engine_setup.js";
import { ICamera } from "./engine_types.js";
import { RGBAColor } from "./js-extensions/index.js";

declare type ScreenshotImageMimeType = "image/webp" | "image/png";

/** 
 * Take a screenshot from the current scene.  
 * **NOTE**: Use {@link screenshot2} for more options.  
 * 
 * @param context The context to take the screenshot from
 * @param width The width of the screenshot
 * @param height The height of the screenshot
 * @param mimeType The mime type of the image
 * @param camera The camera to use for the screenshot
 * @returns The data url of the screenshot. Returns null if the screenshot could not be taken.
 * @example
 * ```ts
 * const dataUrl = screenshot();
 * saveImage(dataUrl, "screenshot.png");
 * ```
 */
export function screenshot(context?: Context, width?: number, height?: number, mimeType: ScreenshotImageMimeType = "image/webp", camera?: Camera | null): string | null {
    return screenshot2({ context, width, height, mimeType, camera });
}


/**
 * Options for the {@link screenshot2} function.
 */
export declare type ScreenshotOptions = {
    /**
     * The context to take the screenshot from. If not provided, the current context will be used.
     */
    context?: Pick<Context, "scene" | "renderer" | "mainCamera" | "renderNow" | "updateAspect" | "updateSize">,
    /**
     * The width of the screenshot - if not provided, the width of the current renderer will be used.
     */
    width?: number,
    /**
     * The height of the screenshot - if not provided, the height of the current renderer will be used.
     */
    height?: number,
    /**
     * The mime type of the image
     */
    mimeType?: ScreenshotImageMimeType,
    /**
     * The camera to use for the screenshot. If not provided, the main camera of the context will be used.
     */
    camera?: Camera | ICamera | null,
    /**
     * If true, the background will be transparent.
     */
    transparent?: boolean,

    /**
     * The background of the screenshot. If not provided, the currently set background of the renderer/scene will be used
     */
    background?: Color | RGBAColor | ColorRepresentation,

    /**
     * If true onBeforeRender and onAfterRender will be invoked on all renderers in the scene.
     * @default true
     */
    render_events?: boolean,
};


export declare type ScreenshotOptionsDataUrl = ScreenshotOptions & {
    /**
     * If set the screenshot will be downloaded using the provided filename.   
     * NOTE: if you need more control you can manually download the returned image using {@link saveImage}
     * @default undefined
     */
    download_filename?: string,
}

export declare type ScreenshotOptionsTexture = ScreenshotOptions & {
    type: "texture",
    /**
     * If set the screenshot will be saved to the provided texture.
     * @default undefined
     */
    target?: Texture,
}

export declare type ScreenshotOptionsBlob = ScreenshotOptions & {
    type: "blob",
}

/** 
 * Take a screenshot from the current scene and return a {@link Texture}. This can applied to a surface in 3D space.
 * @param opts Provide `{ type: "texture" }` to get a texture instead of a data url.
 * @returns The texture of the screenshot. Returns null if the screenshot could not be taken.
 */
export function screenshot2(opts: ScreenshotOptionsTexture): Texture | null;
/**
 * Take a screenshot from the current scene.  
 * @param opts
 * @returns The data url of the screenshot. Returns null if the screenshot could not be taken.
 * ```ts	
 * const res = screenshot2({
 *    width: 1024,
 *   height: 1024,
 *  mimeType: "image/webp",
 * transparent: true,
 * })
 * // use saveImage to download the image
 * saveImage(res, "screenshot.webp");
 * ```
 */
export function screenshot2(opts: ScreenshotOptionsDataUrl): string | null;
/**
 * Take a screenshot asynchronously from the current scene.
 * @returns A promise that resolves with the blob of the screenshot. Returns null if the screenshot could not be taken.
 * @param {ScreenshotOptionsBlob} opts Set `{ type: "blob" }` to get a blob instead of a data url.
 */
export function screenshot2(opts: ScreenshotOptionsBlob): Promise<Blob | null>;
export function screenshot2(opts: ScreenshotOptionsDataUrl | ScreenshotOptionsTexture | ScreenshotOptionsBlob): Texture | string | null | Promise<Blob | null> {

    if (!opts) opts = {}

    const { mimeType = "image/png", transparent = false } = opts;
    let { context, width, height, camera } = opts;

    if (!context) {
        context = ContextRegistry.Current as Context;
        if (!context) {
            console.error("Can not save screenshot: No needle-engine context found or provided.");
            return null;
        }
    }

    if (!camera) {
        camera = context.mainCamera;
        if (!camera) {
            console.error("No camera found");
            return null;
        }
    }

    const prevWidth = context.renderer.domElement.width;
    const prevHeight = context.renderer.domElement.height;

    if (!width) width = prevWidth;
    if (!height) height = prevHeight;

    // apply page zoom
    const zoomLevel = window.devicePixelRatio || 1;
    width /= zoomLevel;
    height /= zoomLevel;

    // save XR state and reset it for screenshot
    const previousXRState = context.renderer.xr.enabled;
    context.renderer.xr.enabled = false;

    // reset style during screenshot
    context.renderer.domElement.style.width = width + "px";
    context.renderer.domElement.style.height = height + "px";

    const prevRenderTarget = context.renderer.getRenderTarget();
    const previousClearColor = context.renderer.getClearColor(new Color());
    const previousClearAlpha = context.renderer.getClearAlpha();
    const previousBackground = context.scene.background;
    const previousAspect: number | null = "aspect" in camera ? camera.aspect : null;

    try {

        const canvas = context.renderer.domElement;


        // Calling onBeforeRender to update objects with reflection probes. https://linear.app/needle/issue/NE-5112
        const callRenderEvents = opts.render_events !== false;
        const renderers = new Array<Renderer>();
        if (callRenderEvents) {
            getComponentsInChildren(context.scene, Renderer, renderers);
            renderers.forEach(r => r?.onBeforeRender());
        }

        if (transparent) {
            context.scene.background = null;
            context.renderer.setClearColor(0x000000, 0);
        }
        if (opts.background) {
            context.scene.background = null;
            context.renderer.setClearColor(opts.background);
            if (opts.background instanceof RGBAColor) {
                context.renderer.setClearAlpha(opts.background.a);
            }
        }
        if (transparent) {
            context.renderer.setClearAlpha(0);
        }

        // set the desired output size
        context.renderer.setSize(width, height, false);

        // If a camera component was provided
        if ("cam" in camera) {
            camera = camera.threeCamera;
        }
        // update the camera aspect and matrix
        if (camera instanceof PerspectiveCamera) {
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }

        const textureOutput = "type" in opts && opts.type === "texture";
        let targetTexture: WebGLRenderTarget | null = null;

        if (textureOutput) {
            targetTexture = new WebGLRenderTarget(width, height, {
                wrapS: MirroredRepeatWrapping,
                wrapT: MirroredRepeatWrapping,
                format: 1023,
            });
            context.renderer.setRenderTarget(targetTexture);
        }

        // render now
        context.renderNow(camera || null);

        if (callRenderEvents)
            renderers.forEach(r => r.onAfterRender());

        if ("type" in opts) {
            if (opts.type === "texture") {
                if (!targetTexture) {
                    console.error("No target texture found");
                    return null;
                }
                if (opts.target) {
                    opts.target.image = targetTexture?.texture.image;
                    opts.target.needsUpdate = true;
                }
                targetTexture.texture.offset.set(0, -1);
                targetTexture.texture.needsUpdate = true;
                return targetTexture.texture;
            }
            else if (opts.type === "blob") {
                const promise = new Promise<Blob | null>((resolve, _) => {
                    canvas.toBlob(blob => {
                        resolve(blob);
                    }, mimeType);
                });
                return promise;
            }
        }

        const dataUrl = canvas.toDataURL(mimeType);

        if ("download_filename" in opts && opts.download_filename) {
            saveImage(dataUrl, opts.download_filename);
        }

        return dataUrl;
    }
    finally {
        context.renderer.setRenderTarget(prevRenderTarget);
        context.scene.background = previousBackground;
        context.renderer.setSize(prevWidth, prevHeight, false);
        context.updateSize(true);
        context.renderer.setClearColor(previousClearColor, previousClearAlpha);
        // Make sure to reset the aspect ratio. This is crucial if the main camera is not the currently active rendering camera
        // For example if we did a screenshot from a different camera that has a different aspect ratio / fov
        if (previousAspect != null && camera instanceof PerspectiveCamera) {
            camera.aspect = previousAspect;
            camera.updateProjectionMatrix();
        }
        context.renderer.xr.enabled = previousXRState;
    }

    return null;
}

let saveImageElement: HTMLAnchorElement | null = null;

/** Download a image (must be a data url).
 * @param dataUrl The data url of the image
 * @param filename The filename of the image
 * @example
 * ```ts
 * const dataUrl = screenshot();
 * saveImage(dataUrl, "screenshot.png");
 * ```
 */
export function saveImage(dataUrl: string | null, filename: string) {
    if (!dataUrl) {
        return;
    }
    if (!dataUrl.startsWith("data:image")) {
        console.error("Can not save image: Data url is not an image", dataUrl);
        return;
    }
    if (!saveImageElement) {
        saveImageElement = document.createElement("a");
    }
    saveImageElement.href = dataUrl;
    saveImageElement.download = filename;
    saveImageElement.click();
}
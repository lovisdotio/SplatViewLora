import { AxesHelper, Box3, Object3D, Vector2, Vector3 } from "three";
import type { GLTF } from "three/examples/jsm/loaders/GLTFLoader.js";

import { isDevEnvironment } from "../engine/debug/index.js";
import { AnimationUtils } from "../engine/engine_animation.js";
import { addComponent } from "../engine/engine_components.js";
import { destroy } from "../engine/engine_gameobject.js";
import { Gizmos } from "../engine/engine_gizmos.js";
import * as files from "../engine/engine_networking_files.js";
import { serializable } from "../engine/engine_serialization_decorator.js";
import { fitObjectIntoVolume, placeOnSurface } from "../engine/engine_three_utils.js";
import { Vec3 } from "../engine/engine_types.js";
import { getParam } from "../engine/engine_utils.js";
import { Animation } from "./Animation.js";
import { Behaviour } from "./Component.js";
import { EventList } from "./EventList.js";

const debug = getParam("debugdroplistener");

export enum DropListenerEvents {
    /**
     * Dispatched when a file is dropped into the scene. The detail of the event is the file that was dropped.
     */
    FileDropped = "file-dropped",
    /**
     * Dispatched when a new object is added to the scene. The detail of the event is the glTF that was added.
     */
    ObjectAdded = "object-added",
}

declare type DropContext = {
    screenposition: Vector2;
    url?: string,
}

declare type DropListenerNetworkEvent = {
    guid: string,
    url: string | string[],
    point: Vec3;
}

/** The DropListener component is used to listen for drag and drop events in the browser and add the dropped files to the scene  
 * It can be used to allow users to drag and drop glTF files into the scene to add new objects.  
 * 
 * ## Events
 * - **object-added** - dispatched when a new object is added to the scene
 * - **file-dropped** - dispatched when a file is dropped into the scene
 * 
 * @example
 * ```typescript
 * import { DropListener, DropListenerEvents } from "@needle-tools/engine";
 * 
 * const dropListener = new DropListener();
 * 
 * gameObject.addComponent(dropListener);
 * dropListener.on(DropListenerEvents.FileDropped, (evt) => {
 *   console.log("File dropped", evt.detail);
 *   const file = evt.detail as File;
 * });
 * 
 * dropListener.on(DropListenerEvents.ObjectAdded, (evt) => {
 *    console.log("Object added", evt.detail);
 *    const gltf = evt.detail as GLTF;
 * });
 * ```
 * 
 * @category Asset Management
 */
export class DropListener extends Behaviour {

    /**
     * When assigned the Droplistener will only accept files that are dropped on this object.
     */
    @serializable(Object3D)
    dropArea?: Object3D;

    /**
     * When enabled the object will be fitted into a volume. Use {@link fitVolumeSize} to specify the volume size.
     * @default false
     */
    @serializable()
    fitIntoVolume: boolean = false;

    /**
     * The volume size will be used to fit the object into the volume. Use {@link fitIntoVolume} to enable this feature.
     */
    @serializable(Vector3)
    fitVolumeSize = new Vector3(1, 1, 1);

    /** When enabled the object will be placed at the drop position (under the cursor)
     * @default true
     */
    @serializable()
    placeAtHitPosition: boolean = true;


    @serializable(EventList)
    onDropped: EventList = new EventList();


    /** @internal */
    onEnable(): void {
        this.context.renderer.domElement.addEventListener("dragover", this.onDrag);
        this.context.renderer.domElement.addEventListener("drop", this.onDrop);
        window.addEventListener("keyup", this.handlePaste);
        this.context.connection.beginListen("droplistener", this.onNetworkEvent)
    }
    /** @internal */
    onDisable(): void {
        this.context.renderer.domElement.removeEventListener("dragover", this.onDrag);
        this.context.renderer.domElement.removeEventListener("drop", this.onDrop);
        window.removeEventListener("keyup", this.handlePaste);
        this.context.connection.stopListen("droplistener", this.onNetworkEvent)
    }

    private onNetworkEvent = (evt: DropListenerNetworkEvent) => {
        if (evt.guid?.startsWith(this.guid)) {
            const url = evt.url;
            if (url) {
                if (Array.isArray(url)) {
                    for (const _url of url) {
                        this.addFromUrl(_url, { screenposition: new Vector2() }, true).then(res => {
                            res?.position.set(evt.point.x, evt.point.y, evt.point.z);
                        })
                    }
                }
                else {
                    this.addFromUrl(url, { screenposition: new Vector2() }, true).then(res => {
                        res?.position.set(evt.point.x, evt.point.y, evt.point.z);
                    })
                }
            }
        }
    }

    private handlePaste = async (evt: KeyboardEvent) => {
        if (this.context.connection.allowEditing === false) return;
        // detect paste 
        const isPasteCommand = (evt.ctrlKey || evt.metaKey) && evt.key === "v";
        if (isPasteCommand) {
            const clipboard = navigator.clipboard;
            const value = await clipboard.readText().catch(console.warn);
            if (value) {
                const isUrl = value.startsWith("http") || value.startsWith("https") || value.startsWith("blob");
                if (isUrl) {
                    const ctx = { screenposition: new Vector2(this.context.input.mousePosition.x, this.context.input.mousePosition.y) };
                    if (this.testIfIsInDropArea(ctx))
                        this.addFromUrl(value, ctx, false);
                }
            }
        }
    }

    private onDrag = (evt: DragEvent) => {
        if (this.context.connection.allowEditing === false) return;
        // necessary to get drop event
        evt.preventDefault();
    }

    private onDrop = async (evt: DragEvent) => {
        if (this.context.connection.allowEditing === false) return;

        if (debug) console.log(evt);
        if (!evt?.dataTransfer) return;
        // If the event is marked as handled for droplisteners then ignore it
        if (evt["droplistener:handled"]) return;
        evt.preventDefault();

        const ctx: DropContext = { screenposition: new Vector2(evt.offsetX, evt.offsetY) };

        if (this.dropArea) {
            const res = this.testIfIsInDropArea(ctx);
            if (res === false) return;
        }

        // Don't stop propagation because this will break e.g. the RemoteSkybox drop
        // evt.stopImmediatePropagation();
        // Mark the event handled for droplisteners
        evt["droplistener:handled"] = true;

        const items = evt.dataTransfer.items;
        if (!items) return;

        for (const ite in items) {
            const it = items[ite];
            if (it.kind === "file") {
                const file = it.getAsFile();
                if (!file) continue;
                await this.addFiles([file], ctx);
            }
            else if (it.kind === "string" && it.type == "text/plain") {
                it.getAsString(str => {
                    this.addFromUrl(str, ctx, false);
                });
            }
        }
    }

    private async addFromUrl(url: string, ctx: DropContext, isRemote: boolean) {
        if (debug) console.log("dropped url", url);

        try {
            if (url.startsWith("https://github.com/")) {
                // make raw.githubusercontent.com url
                const parts = url.split("/");
                const user = parts[3];
                const repo = parts[4];
                const branch = parts[6];
                const path = parts.slice(7).join("/");
                url = `https://raw.githubusercontent.com/${user}/${repo}/${branch}/${path}`;
            }
            else if (url.startsWith("https://polyhaven.com/a")) {
                url = tryResolvePolyhavenAssetUrl(url);
            }
            if (!url) return null;

            // Ignore dropped images
            const lowercaseUrl = url.toLowerCase();
            if (lowercaseUrl.endsWith(".hdr") || lowercaseUrl.endsWith(".hdri") || lowercaseUrl.endsWith(".exr") || lowercaseUrl.endsWith(".png") || lowercaseUrl.endsWith(".jpg") || lowercaseUrl.endsWith(".jpeg")) {
                return null;
            }

            const res = await files.addFileFromUrl(new URL(url), this.context);
            if (res) {
                ctx.url = url;
                const obj = this.addObject(res, ctx, isRemote);
                return obj;
            }
        }
        catch (_) {
            console.warn("String is not a valid URL", url);
        }

        return null;
    }

    private async addFiles(fileList: Array<File>, ctx: DropContext) {
        if (debug) console.log("Add files", fileList)
        if (!Array.isArray(fileList)) return;
        if (!fileList.length) return;

        for (const file of fileList) {
            if (!file) continue;
            if (debug) console.log("Register file " + file.name, file);
            const res = await files.addFile(file, this.context);
            this.dispatchEvent(new CustomEvent(DropListenerEvents.FileDropped, { detail: file }));
            if (res)
                this.addObject(res, ctx, false);
        }
    }

    /** Previously added objects */
    private readonly _addedObjects = new Array<Object3D>();

    private addObject(gltf: GLTF, ctx: DropContext, isRemote: boolean): Object3D | null {
        if (debug) console.log(`Dropped ${this.gameObject.name}`, gltf);
        if (!gltf?.scene) {
            console.warn("No object specified to add to scene", gltf);
            return null;
        }

        for (const prev of this._addedObjects) {
            if (prev.parent === this.gameObject) {
                destroy(prev, true, true);
            }
        }
        this._addedObjects.length = 0;

        const obj = gltf.scene;

        // use attach to ignore the DropListener scale (e.g. if the parent object scale is not uniform)
        this.gameObject.attach(obj);
        obj.position.set(0, 0, 0);
        obj.quaternion.identity();

        this._addedObjects.push(obj);

        if (debug) obj.add(new AxesHelper(1));


        const volume = new Box3().setFromCenterAndSize(new Vector3(0, this.fitVolumeSize.y * .5, 0).add(this.gameObject.worldPosition), this.fitVolumeSize);
        if (debug) Gizmos.DrawWireBox3(volume, 0x0000ff, 5);
        if (this.fitIntoVolume) {
            fitObjectIntoVolume(obj, volume, {
                position: !this.placeAtHitPosition
            });
        }

        if (this.placeAtHitPosition && ctx && ctx.screenposition) {
            obj.visible = false; // < don't raycast on the placed object
            const rc = this.context.physics.raycast({ screenPoint: this.context.input.convertScreenspaceToRaycastSpace(ctx.screenposition.clone()) });
            obj.visible = true;
            if (rc && rc.length > 0) {
                for (const hit of rc) {
                    const pos = hit.point.clone();
                    if (debug) console.log("Place object at hit", hit);
                    placeOnSurface(obj, pos);
                    break;
                }
            }
        }

        AnimationUtils.assignAnimationsFromFile(gltf, {
            createAnimationComponent: obj => addComponent(obj, Animation)
        });

        this.dispatchEvent(new CustomEvent(DropListenerEvents.ObjectAdded, { detail: gltf }));
        this.onDropped?.invoke({ sender: this, gltf })

        // send network event
        if (!isRemote && ctx.url?.startsWith("http") && this.context.connection.isConnected && obj) {
            const evt: DropListenerNetworkEvent = {
                guid: this.guid,
                url: ctx.url,
                point: obj.position.clone(),
            };
            this.context.connection.send("droplistener", evt);
        }

        return obj;
    }



    private testIfIsInDropArea(ctx: DropContext): boolean {
        if (this.dropArea) {
            const screenPoint = this.context.input.convertScreenspaceToRaycastSpace(ctx.screenposition.clone());
            const hits = this.context.physics.raycast({
                targets: [this.dropArea],
                screenPoint,
                recursive: true,
                testObject: obj => {
                    if (this._addedObjects.includes(obj)) return false;
                    return true;
                }
            });
            if (!hits.length) {
                if (isDevEnvironment()) console.log(`Dropped outside of drop area for DropListener \"${this.name}\".`);
                return false;
            }
        }
        return true;
    }

}


function tryResolvePolyhavenAssetUrl(urlStr: string) {
    if (!urlStr.startsWith("https://polyhaven.com/")) return urlStr;
    // Handle dropping polyhaven image url
    const baseUrl = "https://dl.polyhaven.org/file/ph-assets/Models/gltf/4k/";
    const url = new URL(urlStr);
    const path = url.pathname;
    const name = path.split("/").pop();
    const assetUrl = `${baseUrl}${name}/${name}_4k.gltf`;
    console.log("Resolved polyhaven asset url", urlStr, "â†’", assetUrl);
    // TODO: need to resolve textures properly
    return assetUrl;
}
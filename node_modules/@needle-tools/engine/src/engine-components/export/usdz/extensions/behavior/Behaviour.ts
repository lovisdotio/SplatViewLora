import { getParam } from "../../../../../engine/engine_utils.js";
import { GameObject } from "../../../../Component.js";
import type { IUSDExporterExtension } from "../../Extension.js";
import type { USDObject, USDWriter, USDZExporterContext } from "../../ThreeUSDZExporter.js";
import { AudioExtension } from "./AudioExtension.js";
import { ActionModel, type BehaviorModel, GroupActionModel, IBehaviorElement, type Target, TriggerModel } from "./BehavioursBuilder.js";

const debug = getParam("debugusdzbehaviours");

export interface UsdzBehaviour {
    createBehaviours?(ext: BehaviorExtension, model: USDObject, context: USDZExporterContext): void;
    beforeCreateDocument?(ext: BehaviorExtension, context: USDZExporterContext): void | Promise<void>;
    afterCreateDocument?(ext: BehaviorExtension, context: USDZExporterContext): void | Promise<void>
    afterSerialize?(ext: BehaviorExtension, context: USDZExporterContext): void;
}

/** internal USDZ behaviours extension */
export class BehaviorExtension implements IUSDExporterExtension {

    get extensionName(): string {
        return "Behaviour";
    }

    private behaviours: BehaviorModel[] = [];

    addBehavior(beh: BehaviorModel) {
        this.behaviours.push(beh);
    }

    /** Register audio clip for USDZ export. The clip will be embedded in the resulting file. */
    addAudioClip(clipUrl: string) {
        if (!clipUrl) return "";
        if (typeof clipUrl !== "string") return "";

        const clipName = AudioExtension.getName(clipUrl);
        const filesKey = "audio/" + clipName;

        this.audioClips.push({clipUrl, filesKey});

        return filesKey;
    }

    behaviourComponents: Array<UsdzBehaviour> = [];
    private behaviourComponentsCopy: Array<UsdzBehaviour> = [];
    private audioClips: Array<{clipUrl: string, filesKey: string}> = [];
    private audioClipsCopy: Array<{clipUrl: string, filesKey: string}> = [];
    private targetUuids: Set<string> = new Set();
    
    getAllTargetUuids() {
        return this.targetUuids;
    }

    onBeforeBuildDocument(context: USDZExporterContext) {
        if (!context.root) return Promise.resolve();
        const beforeCreateDocumentPromises : Array<Promise<any>> = [];
        context.root.traverse(e => {
            GameObject.foreachComponent(e, (comp) => {
                const c = comp as unknown as UsdzBehaviour;
                // Test if the components has any of the behaviour type methods
                if (
                    typeof c.createBehaviours === "function" ||
                    typeof c.beforeCreateDocument === "function" ||
                    typeof c.afterCreateDocument === "function" ||
                    typeof c.afterSerialize === "function"
                ) {
                    this.behaviourComponents.push(c);
                    // run beforeCreateDocument. We run them in parallel if any of them is async because the order in which this is invoked on the components is not guaranteed anyways 
                    // (or at least no behaviour component should rely on another to have finished this method)
                    const res = c.beforeCreateDocument?.call(c, this, context);
                    if(res instanceof Promise) {
                        beforeCreateDocumentPromises.push(res);
                    }
                }
            }, false);
        });
        if (debug) console.log("onBeforeBuildDocument: all components", this.behaviourComponents);
        return Promise.all(beforeCreateDocumentPromises);
    }

    onExportObject(_object, model: USDObject, context) {
        for (const beh of this.behaviourComponents) {
            if (debug) console.log("onExportObject: createBehaviours", beh);
            beh.createBehaviours?.call(beh, this, model, context);
        }
    }

    onAfterBuildDocument(context: USDZExporterContext) {
        for (const beh of this.behaviourComponents) {
            if (typeof beh.afterCreateDocument === "function")
                beh.afterCreateDocument(this, context);
        }
        this.behaviourComponentsCopy = this.behaviourComponents.slice();
        this.behaviourComponents.length = 0;
        this.audioClipsCopy = this.audioClips.slice();
        this.audioClips.length = 0;

        // We want to know all trigger sources and action targets.
        // These can be nested in Group Actions.

        const triggerSources = new Set<Target>();
        const actionTargets = new Set<Target>();
        const targetUuids = new Set<string>();

        function collect (actionModel: IBehaviorElement) {
            if (actionModel instanceof GroupActionModel) {
                for (const action of actionModel.actions) {
                    collect(action);
                }
            }
            else if (actionModel instanceof ActionModel) {
                const affected = actionModel.affectedObjects;
                if (affected) {
                    if (typeof affected === "object")
                        actionTargets.add(affected as Target);
                    else if (typeof affected === "string")
                        actionTargets.add({uuid: affected} as any as Target);
                }

                const xform = actionModel.xFormTarget;
                if (xform) {
                    if (typeof xform === "object")
                        actionTargets.add(xform as Target);
                    else if (typeof xform === "string")
                        actionTargets.add({uuid: xform} as any as Target);
                }
            }
        }

        // collect all targets of all triggers and actions
        for (const beh of this.behaviours) {
            if (beh.trigger instanceof TriggerModel && typeof beh.trigger.targetId === "object" )
                triggerSources.add(beh.trigger.targetId as Target);
            collect(beh.action);
        }

        for (const source of new Set([...triggerSources, ...actionTargets])) {
            // shouldn't happen but strictly speaking a trigger source could be set to an array
            if (Array.isArray(source)) {
                for (const s of source)
                    targetUuids.add(s.uuid);
            }
            else
                targetUuids.add(source.uuid);
        }

        if (debug) console.log("All Behavior trigger sources and action targets", triggerSources, actionTargets, targetUuids);
        this.targetUuids = new Set(targetUuids);
    }

    onAfterHierarchy(context: USDZExporterContext, writer: USDWriter) {
        if (this.behaviours?.length) {
            writer.beginBlock('def Scope "Behaviors"');

            for (const beh of this.behaviours)
                beh.writeTo(this, context.document, writer);

            writer.closeBlock();
        }
    }

    async onAfterSerialize(context: USDZExporterContext) {
        if (debug) console.log("onAfterSerialize behaviours", this.behaviourComponentsCopy)
        
        for (const beh of this.behaviourComponentsCopy) {
            
            if (typeof beh.afterSerialize === "function") {

                const isAsync = beh.afterSerialize.constructor.name === "AsyncFunction";
				
				if ( isAsync ) {
					await beh.afterSerialize(this, context);
				} else {
					beh.afterSerialize(this, context);
				}
            }
        }

        for (const { clipUrl, filesKey } of this.audioClipsCopy) {
    
            // if the clip was already added, don't add it again
            if (context.files[filesKey]) return;
    
            const audio = await fetch(clipUrl);
            const audioBlob = await audio.blob();
            const arrayBuffer = await audioBlob.arrayBuffer();
            const audioData: Uint8Array = new Uint8Array(arrayBuffer)
            context.files[filesKey] = audioData;
        }

        // cleanup
        this.behaviourComponentsCopy.length = 0;
        this.audioClipsCopy.length = 0;
    }

    // combine behaviours that have tap triggers on the same object
    // private combineBehavioursWithSameTapActions() {
    //     // TODO: if behaviours have different settings (e.g. one is exclusive and another one is not) this wont work - we need more logic for that

    //     const combined: { [key: string]: { behaviorId: string, trigger: TriggerModel, actions: IBehaviorElement[] } } = {};

    //     for (let i = this.behaviours.length - 1; i >= 0; i--) {
    //         const beh = this.behaviours[i];
    //         const trigger = beh.trigger as TriggerModel;
    //         if (!Array.isArray(trigger) && TriggerBuilder.isTapTrigger(trigger)) {
    //             const targetObject = trigger.targetId;
    //             if (!targetObject) continue;
    //             if (!combined[targetObject]) {
    //                 combined[targetObject] = { behaviorId: beh.id, trigger: trigger, actions: [] };
    //             }
    //             const action = beh.action;
    //             combined[targetObject].actions.push(action);
    //             this.behaviours.splice(i, 1);
    //         }
    //     }
    //     for (const key in combined) {
    //         const val = combined[key];
    //         console.log("Combine " + val.actions.length + " actions on " + val.trigger.id, val.actions);
    //         const beh = new BehaviorModel(val.behaviorId, val.trigger, ActionBuilder.sequence(...val.actions));
    //         this.behaviours.push(beh);
    //     }
    // }
}




        // const playAnimationOnTap = new BehaviorModel("b_" + model.name + "_playanim", TriggerBuilder.tapTrigger(model),
        //     ActionBuilder.parallel(
        //         ActionBuilder.lookAtCameraAction(model),
        //         ActionBuilder.sequence(
        //             //ActionBuilder.startAnimationAction(model, 0, 0, 1, false, true),
        //             ActionBuilder.emphasize(model, 1, MotionType.Float),
        //             ActionBuilder.waitAction(1),
        //             ActionBuilder.emphasize(model, 1, MotionType.Blink),
        //             ActionBuilder.waitAction(1),
        //             ActionBuilder.emphasize(model, 1, MotionType.Jiggle),
        //             ActionBuilder.waitAction(1),
        //             ActionBuilder.emphasize(model, 1, MotionType.Pulse),
        //             ActionBuilder.waitAction(1),
        //             ActionBuilder.emphasize(model, 1, MotionType.Spin),
        //             ActionBuilder.waitAction(1),
        //             ActionBuilder.emphasize(model, 1, MotionType.Bounce),
        //             ActionBuilder.waitAction(1),
        //             ActionBuilder.emphasize(model, 1, MotionType.Flip),
        //             ActionBuilder.waitAction(1),
        //         ).makeLooping()
        //     ).makeLooping()
        // );
        // this.behaviours.push(playAnimationOnTap);
        // return;

        // const identityMatrix = new Matrix4().identity();

        // const emptyParent = new USDZObject(model.name + "_empty", model.matrix);
        // const parent = model.parent;
        // parent.add(emptyParent);
        // model.matrix = identityMatrix;
        // emptyParent.add(model);


        // const geometry = new SphereGeometry(.6, 32, 16);
        // const modelVariant = new USDZObject(model.name + "_variant", identityMatrix, geometry, new MeshStandardMaterial({ color: 0xff0000 }));
        // emptyParent.add(modelVariant);

        // const matrix2 = new Matrix4();
        // matrix2.makeTranslation(.5, 0, 0);
        // const modelVariant2 = new USDZObject(model.name + "_variant2", matrix2, geometry, new MeshStandardMaterial({ color: 0xffff00 }));
        // emptyParent.add(modelVariant2);

        // const hideVariantOnStart = new BehaviorModel("b_" + model.name + "_start", TriggerBuilder.sceneStartTrigger(), ActionBuilder.fadeAction(modelVariant, 0, false));
        // this.behaviours.push(hideVariantOnStart);

        // const showVariant = new BehaviorModel("b_" + model.name + "_show_variant", [TriggerBuilder.tapTrigger(model)], new GroupActionModel("group", [
        //     ActionBuilder.fadeAction(model, 0, false),
        //     ActionBuilder.fadeAction(modelVariant, 0, true),
        // ]));
        // this.behaviours.push(showVariant);

        // const showOriginal = new BehaviorModel("b_" + model.name + "_show_original", [
        //     TriggerBuilder.tapTrigger(modelVariant),
        //     TriggerBuilder.tapTrigger(modelVariant2)
        // ],
        //     new GroupActionModel("group", [
        //         ActionBuilder.fadeAction([modelVariant, modelVariant2], 0, false),
        //         //ActionBuilder.waitAction(1),
        //         ActionBuilder.fadeAction(model, 0, true),
        //         //ActionBuilder.waitAction(.2),
        //         ActionBuilder.startAnimationAction(model, 0, 1000, 1, false, true),
        //         //ActionBuilder.lookAtCameraAction(model, 2, Vec3.forward, Vec3.up),
        //         //ActionBuilder.waitAction(1),
        //         //ActionBuilder.fadeAction(modelVariant2, 0, true),
        //     ]).makeSequence());
        // this.behaviours.push(showOriginal);
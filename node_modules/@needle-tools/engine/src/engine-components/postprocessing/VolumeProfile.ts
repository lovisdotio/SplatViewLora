import { serializeable } from "../../engine/engine_serialization_decorator.js";
import { getParam } from "../../engine/engine_utils.js";
import { PostProcessingEffect } from "./PostProcessingEffect.js";

const debug = getParam("debugpost");

const customEffects: { [name: string]: typeof PostProcessingEffect } = {};
export function registerCustomEffectType(name: string, effect: typeof PostProcessingEffect) {
    customEffects[name] = effect;
}

// resolve the types:
function resolveComponentType(data: { __type: string }) {
    if (data.__type in customEffects)
        return customEffects[data.__type];
    // if ("mode" in data) return ToneMapping;
    // if ("postExposure" in data) return ColorAdjustments;
    // switch (data.__type) {
    //     // case "Bloom": return Bloom;
    //     // case "DepthOfField": return DepthOfField;
    //     // case "Vignette": return Vignette
    //     // case "ColorAdjustments": return ColorAdjustments;
    //     // case "Tonemapping": return ToneMapping;
    // }
    if (debug && data.__type)
        console.warn("Unknown postprocessing type", data.__type, data)
    return PostProcessingEffect;
}

/** @internal */
export class VolumeProfile {

    /** effects added to the volume */
    @serializeable([d => resolveComponentType(d), PostProcessingEffect])
    components: PostProcessingEffect[] = [];

    /**
     * call init on all components 
     * @hidden
     **/
    init() {
        this.components?.forEach(c => c.init());
    }

    addEffect(effect: PostProcessingEffect) {
        this.components.push(effect);
    }
    removeEffect(effect: PostProcessingEffect) {
        const idx = this.components.indexOf(effect);
        if (idx >= 0) this.components.splice(idx, 1);
    }
}


import { Object3D, Quaternion, Vector3 } from "three";

import { isDevEnvironment } from "../engine/debug/index.js";
import { InstantiateOptions } from "../engine/engine_gameobject.js";
import { InstantiateIdProvider } from "../engine/engine_networking_instantiate.js";
import { serializable } from "../engine/engine_serialization_decorator.js";
import { Behaviour, GameObject } from "./Component.js";
import { DragControls, DragMode } from "./DragControls.js";
import { SyncedTransform } from "./SyncedTransform.js";
import { type IPointerEventHandler, PointerEventData } from "./ui/PointerEvents.js";
import { ObjectRaycaster } from "./ui/Raycaster.js";

/**
 * The Duplicatable component is used to duplicate a assigned {@link GameObject} when a pointer event occurs on the GameObject.  
 * It implements the {@link IPointerEventHandler} interface and can be used to expose duplication to the user in the editor without writing code.
 * @category Interactivity
 */
export class Duplicatable extends Behaviour implements IPointerEventHandler {

    /** Duplicates will be parented into the set object. If not defined, this GameObject will be used as parent. */
    @serializable(Object3D)
    parent: GameObject | null = null;

    /** The object to be duplicated. If no object is assigned then the object the Duplicatable component is attached to will be used for cloning.
     * @default null
     */
    @serializable(Object3D)
    object: GameObject | null = null;

    /**
     * The maximum number of objects that can be duplicated in the interval.
     * @default 10
     */
    @serializable()
    limitCount = 10;

    /**
     * The interval in seconds in which the limitCount is reset.
     * @default 60
     */
    @serializable()
    limitInterval = 60;

    private _currentCount = 0;
    private _startPosition: Vector3 | null = null;
    private _startQuaternion: Quaternion | null = null;

    start(): void {
        this._currentCount = 0;
        this._startPosition = null;
        this._startQuaternion = null;

        if (!this.object) {
            this.object = this.gameObject;
        }

        if (this.object) {
            if (this.object === this.gameObject) {
                // console.error("Can not duplicate self");
                // return;
                const instanceIdProvider = new InstantiateIdProvider(this.guid);
                this.object = GameObject.instantiate(this.object, { idProvider: instanceIdProvider, keepWorldPosition: false, });
                const duplicatable = GameObject.getComponent(this.object, Duplicatable);
                duplicatable?.destroy();
                let dragControls = this.object.getComponentInChildren(DragControls);
                if (!dragControls) {
                    dragControls = this.object.addComponent(DragControls, {
                        dragMode: DragMode.SnapToSurfaces
                    });
                    dragControls.guid = instanceIdProvider.generateUUID();
                }
                let syncedTransfrom = GameObject.getComponent(dragControls.gameObject, SyncedTransform);
                if (!syncedTransfrom) {
                    syncedTransfrom = dragControls.gameObject.addComponent(SyncedTransform);
                    syncedTransfrom.guid = instanceIdProvider.generateUUID();
                }
            }
            this.object.visible = false;

            // legacy â€“ DragControls was required for duplication and so often the component is still there; we work around that by disabling it here
            const dragControls = this.gameObject.getComponent(DragControls);
            if (dragControls) {
                // if (isDevEnvironment()) console.warn(`Please remove DragControls from \"${dragControls.name}\": it's not needed anymore when the object also has a Duplicatable component`);
                dragControls.enabled = false;
            }

            // when this is in a moveable parent in multiuser scenario somehow the object position gets an offset and might stay that way
            // this is just a workaround to set the object position before duplicating
            this._startPosition = this.object.position?.clone() ?? new Vector3(0, 0, 0);
            this._startQuaternion = this.object.quaternion?.clone() ?? new Quaternion(0, 0, 0, 1);
        }


        if (!this.gameObject.getComponentInParent(ObjectRaycaster))
            this.gameObject.addComponent(ObjectRaycaster);

        this.cloneLimitIntervalFn();
    }

    private _forwardPointerEvents: Map<Object3D, DragControls> = new Map();

    onPointerEnter(args: PointerEventData) {
        if (args.used) return;
        if (!this.object) return;
        if (!this.context.connection.allowEditing) return;
        if (args.button !== 0) return;
        this.context.input.setCursorPointer();
    }
    onPointerExit(args: PointerEventData) {
        if (args.used) return;
        if (!this.object) return;
        if (!this.context.connection.allowEditing) return;
        if (args.button !== 0) return;
        this.context.input.setCursorNormal();
    }

    /** @internal */
    onPointerDown(args: PointerEventData) {
        if (args.used) return;
        if (!this.object) return;
        if (!this.context.connection.allowEditing) return;
        if (args.button !== 0) return;
        const res = this.handleDuplication();
        if (res) {
            const dragControls = GameObject.getComponent(res, DragControls);
            if (!dragControls) console.warn("Duplicated object does not have DragControls", res);
            else {
                dragControls.onPointerDown(args);
                this._forwardPointerEvents.set(args.event.space, dragControls);
            }
        }
        else {
            console.warn("Could not duplicate object. Has the target object been destroyed?", this);
        }
    }

    /** @internal */
    onPointerUp(args: PointerEventData) {
        if (args.used) return;
        const dragControls = this._forwardPointerEvents.get(args.event.space);
        if (dragControls) {
            dragControls.onPointerUp(args);
            this._forwardPointerEvents.delete(args.event.space);
        }
    }

    private cloneLimitIntervalFn() {
        if (this.destroyed) return;
        if (this._currentCount > 0) {
            this._currentCount -= 1;
        }
        setTimeout(() => {
            this.cloneLimitIntervalFn();
        }, (this.limitInterval / this.limitCount) * 1000);
    }

    private handleDuplication(): Object3D | null {
        if (!this.object) return null;
        if (this._currentCount >= this.limitCount) return null;
        if (this.object === this.gameObject) return null;
        if (GameObject.isDestroyed(this.object)) {
            this.object = null;
            return null;
        }

        this.object.visible = true;

        if (this._startPosition)
            this.object.position.copy(this._startPosition);
        if (this._startQuaternion)
            this.object.quaternion.copy(this._startQuaternion);

        const opts = new InstantiateOptions();
        if (!this.parent) this.parent = this.gameObject.parent as GameObject;
        if (this.parent) {
            opts.parent = this.parent.guid ?? this.parent.userData?.guid;
            opts.keepWorldPosition = true;
        }
        opts.position = this.worldPosition;
        opts.rotation = this.worldQuaternion;
        opts.context = this.context;
        this._currentCount += 1;

        const newInstance = GameObject.instantiateSynced(this.object as GameObject, opts) as GameObject;
        console.assert(newInstance !== this.object, "Duplicated object is original");
        this.object.visible = false;

        // see if this fixes object being offset when duplicated and dragged - it looks like three clone has shared position/quaternion objects?
        if (this._startPosition)
            this.object.position.clone().copy(this._startPosition);
        if (this._startQuaternion)
            this.object.quaternion.clone().copy(this._startQuaternion);

        return newInstance;
    }
}